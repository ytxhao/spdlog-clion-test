// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: room_message.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_room_5fmessage_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_room_5fmessage_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3019000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3019001 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/map.h>  // IWYU pragma: export
#include <google/protobuf/map_entry_lite.h>
#include <google/protobuf/map_field_lite.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_room_5fmessage_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_room_5fmessage_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[16]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const uint32_t offsets[];
};
namespace zorro {
namespace protobuf {
class Candidate;
struct CandidateDefaultTypeInternal;
extern CandidateDefaultTypeInternal _Candidate_default_instance_;
class Content;
struct ContentDefaultTypeInternal;
extern ContentDefaultTypeInternal _Content_default_instance_;
class Crypto;
struct CryptoDefaultTypeInternal;
extern CryptoDefaultTypeInternal _Crypto_default_instance_;
class Description;
struct DescriptionDefaultTypeInternal;
extern DescriptionDefaultTypeInternal _Description_default_instance_;
class Fingerprint;
struct FingerprintDefaultTypeInternal;
extern FingerprintDefaultTypeInternal _Fingerprint_default_instance_;
class PayloadType;
struct PayloadTypeDefaultTypeInternal;
extern PayloadTypeDefaultTypeInternal _PayloadType_default_instance_;
class PayloadType_ParametersEntry_DoNotUse;
struct PayloadType_ParametersEntry_DoNotUseDefaultTypeInternal;
extern PayloadType_ParametersEntry_DoNotUseDefaultTypeInternal _PayloadType_ParametersEntry_DoNotUse_default_instance_;
class RoomMessage;
struct RoomMessageDefaultTypeInternal;
extern RoomMessageDefaultTypeInternal _RoomMessage_default_instance_;
class RoomMessage_ParameterMapEntry_DoNotUse;
struct RoomMessage_ParameterMapEntry_DoNotUseDefaultTypeInternal;
extern RoomMessage_ParameterMapEntry_DoNotUseDefaultTypeInternal _RoomMessage_ParameterMapEntry_DoNotUse_default_instance_;
class RtcpFBType;
struct RtcpFBTypeDefaultTypeInternal;
extern RtcpFBTypeDefaultTypeInternal _RtcpFBType_default_instance_;
class RtpHdrExt;
struct RtpHdrExtDefaultTypeInternal;
extern RtpHdrExtDefaultTypeInternal _RtpHdrExt_default_instance_;
class SDP;
struct SDPDefaultTypeInternal;
extern SDPDefaultTypeInternal _SDP_default_instance_;
class Source;
struct SourceDefaultTypeInternal;
extern SourceDefaultTypeInternal _Source_default_instance_;
class SourceGroup;
struct SourceGroupDefaultTypeInternal;
extern SourceGroupDefaultTypeInternal _SourceGroup_default_instance_;
class Source_ParametersEntry_DoNotUse;
struct Source_ParametersEntry_DoNotUseDefaultTypeInternal;
extern Source_ParametersEntry_DoNotUseDefaultTypeInternal _Source_ParametersEntry_DoNotUse_default_instance_;
class Transport;
struct TransportDefaultTypeInternal;
extern TransportDefaultTypeInternal _Transport_default_instance_;
}  // namespace protobuf
}  // namespace zorro
PROTOBUF_NAMESPACE_OPEN
template<> ::zorro::protobuf::Candidate* Arena::CreateMaybeMessage<::zorro::protobuf::Candidate>(Arena*);
template<> ::zorro::protobuf::Content* Arena::CreateMaybeMessage<::zorro::protobuf::Content>(Arena*);
template<> ::zorro::protobuf::Crypto* Arena::CreateMaybeMessage<::zorro::protobuf::Crypto>(Arena*);
template<> ::zorro::protobuf::Description* Arena::CreateMaybeMessage<::zorro::protobuf::Description>(Arena*);
template<> ::zorro::protobuf::Fingerprint* Arena::CreateMaybeMessage<::zorro::protobuf::Fingerprint>(Arena*);
template<> ::zorro::protobuf::PayloadType* Arena::CreateMaybeMessage<::zorro::protobuf::PayloadType>(Arena*);
template<> ::zorro::protobuf::PayloadType_ParametersEntry_DoNotUse* Arena::CreateMaybeMessage<::zorro::protobuf::PayloadType_ParametersEntry_DoNotUse>(Arena*);
template<> ::zorro::protobuf::RoomMessage* Arena::CreateMaybeMessage<::zorro::protobuf::RoomMessage>(Arena*);
template<> ::zorro::protobuf::RoomMessage_ParameterMapEntry_DoNotUse* Arena::CreateMaybeMessage<::zorro::protobuf::RoomMessage_ParameterMapEntry_DoNotUse>(Arena*);
template<> ::zorro::protobuf::RtcpFBType* Arena::CreateMaybeMessage<::zorro::protobuf::RtcpFBType>(Arena*);
template<> ::zorro::protobuf::RtpHdrExt* Arena::CreateMaybeMessage<::zorro::protobuf::RtpHdrExt>(Arena*);
template<> ::zorro::protobuf::SDP* Arena::CreateMaybeMessage<::zorro::protobuf::SDP>(Arena*);
template<> ::zorro::protobuf::Source* Arena::CreateMaybeMessage<::zorro::protobuf::Source>(Arena*);
template<> ::zorro::protobuf::SourceGroup* Arena::CreateMaybeMessage<::zorro::protobuf::SourceGroup>(Arena*);
template<> ::zorro::protobuf::Source_ParametersEntry_DoNotUse* Arena::CreateMaybeMessage<::zorro::protobuf::Source_ParametersEntry_DoNotUse>(Arena*);
template<> ::zorro::protobuf::Transport* Arena::CreateMaybeMessage<::zorro::protobuf::Transport>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace zorro {
namespace protobuf {

// ===================================================================

class RtpHdrExt final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:zorro.protobuf.RtpHdrExt) */ {
 public:
  inline RtpHdrExt() : RtpHdrExt(nullptr) {}
  ~RtpHdrExt() override;
  explicit constexpr RtpHdrExt(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RtpHdrExt(const RtpHdrExt& from);
  RtpHdrExt(RtpHdrExt&& from) noexcept
    : RtpHdrExt() {
    *this = ::std::move(from);
  }

  inline RtpHdrExt& operator=(const RtpHdrExt& from) {
    CopyFrom(from);
    return *this;
  }
  inline RtpHdrExt& operator=(RtpHdrExt&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const RtpHdrExt& default_instance() {
    return *internal_default_instance();
  }
  static inline const RtpHdrExt* internal_default_instance() {
    return reinterpret_cast<const RtpHdrExt*>(
               &_RtpHdrExt_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(RtpHdrExt& a, RtpHdrExt& b) {
    a.Swap(&b);
  }
  inline void Swap(RtpHdrExt* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RtpHdrExt* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RtpHdrExt* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RtpHdrExt>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const RtpHdrExt& from);
  void MergeFrom(const RtpHdrExt& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(RtpHdrExt* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "zorro.protobuf.RtpHdrExt";
  }
  protected:
  explicit RtpHdrExt(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
    kUriFieldNumber = 2,
  };
  // string id = 1;
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // string uri = 2;
  void clear_uri();
  const std::string& uri() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_uri(ArgT0&& arg0, ArgT... args);
  std::string* mutable_uri();
  PROTOBUF_NODISCARD std::string* release_uri();
  void set_allocated_uri(std::string* uri);
  private:
  const std::string& _internal_uri() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_uri(const std::string& value);
  std::string* _internal_mutable_uri();
  public:

  // @@protoc_insertion_point(class_scope:zorro.protobuf.RtpHdrExt)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr uri_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_room_5fmessage_2eproto;
};
// -------------------------------------------------------------------

class RtcpFBType final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:zorro.protobuf.RtcpFBType) */ {
 public:
  inline RtcpFBType() : RtcpFBType(nullptr) {}
  ~RtcpFBType() override;
  explicit constexpr RtcpFBType(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RtcpFBType(const RtcpFBType& from);
  RtcpFBType(RtcpFBType&& from) noexcept
    : RtcpFBType() {
    *this = ::std::move(from);
  }

  inline RtcpFBType& operator=(const RtcpFBType& from) {
    CopyFrom(from);
    return *this;
  }
  inline RtcpFBType& operator=(RtcpFBType&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const RtcpFBType& default_instance() {
    return *internal_default_instance();
  }
  static inline const RtcpFBType* internal_default_instance() {
    return reinterpret_cast<const RtcpFBType*>(
               &_RtcpFBType_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(RtcpFBType& a, RtcpFBType& b) {
    a.Swap(&b);
  }
  inline void Swap(RtcpFBType* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RtcpFBType* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RtcpFBType* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RtcpFBType>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const RtcpFBType& from);
  void MergeFrom(const RtcpFBType& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(RtcpFBType* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "zorro.protobuf.RtcpFBType";
  }
  protected:
  explicit RtcpFBType(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTypeFieldNumber = 1,
    kSubTypeFieldNumber = 2,
  };
  // string type = 1;
  void clear_type();
  const std::string& type() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_type(ArgT0&& arg0, ArgT... args);
  std::string* mutable_type();
  PROTOBUF_NODISCARD std::string* release_type();
  void set_allocated_type(std::string* type);
  private:
  const std::string& _internal_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_type(const std::string& value);
  std::string* _internal_mutable_type();
  public:

  // string subType = 2;
  void clear_subtype();
  const std::string& subtype() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_subtype(ArgT0&& arg0, ArgT... args);
  std::string* mutable_subtype();
  PROTOBUF_NODISCARD std::string* release_subtype();
  void set_allocated_subtype(std::string* subtype);
  private:
  const std::string& _internal_subtype() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_subtype(const std::string& value);
  std::string* _internal_mutable_subtype();
  public:

  // @@protoc_insertion_point(class_scope:zorro.protobuf.RtcpFBType)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr type_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr subtype_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_room_5fmessage_2eproto;
};
// -------------------------------------------------------------------

class PayloadType_ParametersEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntryLite<PayloadType_ParametersEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntryLite<PayloadType_ParametersEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> SuperType;
  PayloadType_ParametersEntry_DoNotUse();
  explicit constexpr PayloadType_ParametersEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit PayloadType_ParametersEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const PayloadType_ParametersEntry_DoNotUse& other);
  static const PayloadType_ParametersEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const PayloadType_ParametersEntry_DoNotUse*>(&_PayloadType_ParametersEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "zorro.protobuf.PayloadType.ParametersEntry.key");
 }
  static bool ValidateValue(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "zorro.protobuf.PayloadType.ParametersEntry.value");
 }
};

// -------------------------------------------------------------------

class PayloadType final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:zorro.protobuf.PayloadType) */ {
 public:
  inline PayloadType() : PayloadType(nullptr) {}
  ~PayloadType() override;
  explicit constexpr PayloadType(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PayloadType(const PayloadType& from);
  PayloadType(PayloadType&& from) noexcept
    : PayloadType() {
    *this = ::std::move(from);
  }

  inline PayloadType& operator=(const PayloadType& from) {
    CopyFrom(from);
    return *this;
  }
  inline PayloadType& operator=(PayloadType&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const PayloadType& default_instance() {
    return *internal_default_instance();
  }
  static inline const PayloadType* internal_default_instance() {
    return reinterpret_cast<const PayloadType*>(
               &_PayloadType_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(PayloadType& a, PayloadType& b) {
    a.Swap(&b);
  }
  inline void Swap(PayloadType* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PayloadType* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PayloadType* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PayloadType>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const PayloadType& from);
  void MergeFrom(const PayloadType& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(PayloadType* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "zorro.protobuf.PayloadType";
  }
  protected:
  explicit PayloadType(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kParametersFieldNumber = 5,
    kRtcpFbFieldNumber = 6,
    kNameFieldNumber = 2,
    kIdFieldNumber = 1,
    kClockrateFieldNumber = 3,
    kChannelsFieldNumber = 4,
  };
  // map<string, string> parameters = 5;
  int parameters_size() const;
  private:
  int _internal_parameters_size() const;
  public:
  void clear_parameters();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      _internal_parameters() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      _internal_mutable_parameters();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      parameters() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      mutable_parameters();

  // repeated .zorro.protobuf.RtcpFBType rtcpFb = 6;
  int rtcpfb_size() const;
  private:
  int _internal_rtcpfb_size() const;
  public:
  void clear_rtcpfb();
  ::zorro::protobuf::RtcpFBType* mutable_rtcpfb(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zorro::protobuf::RtcpFBType >*
      mutable_rtcpfb();
  private:
  const ::zorro::protobuf::RtcpFBType& _internal_rtcpfb(int index) const;
  ::zorro::protobuf::RtcpFBType* _internal_add_rtcpfb();
  public:
  const ::zorro::protobuf::RtcpFBType& rtcpfb(int index) const;
  ::zorro::protobuf::RtcpFBType* add_rtcpfb();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zorro::protobuf::RtcpFBType >&
      rtcpfb() const;

  // string name = 2;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // int32 id = 1;
  void clear_id();
  int32_t id() const;
  void set_id(int32_t value);
  private:
  int32_t _internal_id() const;
  void _internal_set_id(int32_t value);
  public:

  // int32 clockrate = 3;
  void clear_clockrate();
  int32_t clockrate() const;
  void set_clockrate(int32_t value);
  private:
  int32_t _internal_clockrate() const;
  void _internal_set_clockrate(int32_t value);
  public:

  // int32 channels = 4;
  void clear_channels();
  int32_t channels() const;
  void set_channels(int32_t value);
  private:
  int32_t _internal_channels() const;
  void _internal_set_channels(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:zorro.protobuf.PayloadType)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::MapFieldLite<
      PayloadType_ParametersEntry_DoNotUse,
      std::string, std::string,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> parameters_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zorro::protobuf::RtcpFBType > rtcpfb_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  int32_t id_;
  int32_t clockrate_;
  int32_t channels_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_room_5fmessage_2eproto;
};
// -------------------------------------------------------------------

class Source_ParametersEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntryLite<Source_ParametersEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntryLite<Source_ParametersEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> SuperType;
  Source_ParametersEntry_DoNotUse();
  explicit constexpr Source_ParametersEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit Source_ParametersEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const Source_ParametersEntry_DoNotUse& other);
  static const Source_ParametersEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const Source_ParametersEntry_DoNotUse*>(&_Source_ParametersEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "zorro.protobuf.Source.ParametersEntry.key");
 }
  static bool ValidateValue(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "zorro.protobuf.Source.ParametersEntry.value");
 }
};

// -------------------------------------------------------------------

class Source final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:zorro.protobuf.Source) */ {
 public:
  inline Source() : Source(nullptr) {}
  ~Source() override;
  explicit constexpr Source(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Source(const Source& from);
  Source(Source&& from) noexcept
    : Source() {
    *this = ::std::move(from);
  }

  inline Source& operator=(const Source& from) {
    CopyFrom(from);
    return *this;
  }
  inline Source& operator=(Source&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const Source& default_instance() {
    return *internal_default_instance();
  }
  static inline const Source* internal_default_instance() {
    return reinterpret_cast<const Source*>(
               &_Source_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(Source& a, Source& b) {
    a.Swap(&b);
  }
  inline void Swap(Source* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Source* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Source* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Source>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const Source& from);
  void MergeFrom(const Source& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Source* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "zorro.protobuf.Source";
  }
  protected:
  explicit Source(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kParametersFieldNumber = 3,
    kSsrcFieldNumber = 1,
    kOwnerFieldNumber = 2,
  };
  // map<string, string> parameters = 3;
  int parameters_size() const;
  private:
  int _internal_parameters_size() const;
  public:
  void clear_parameters();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      _internal_parameters() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      _internal_mutable_parameters();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      parameters() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      mutable_parameters();

  // string ssrc = 1;
  void clear_ssrc();
  const std::string& ssrc() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_ssrc(ArgT0&& arg0, ArgT... args);
  std::string* mutable_ssrc();
  PROTOBUF_NODISCARD std::string* release_ssrc();
  void set_allocated_ssrc(std::string* ssrc);
  private:
  const std::string& _internal_ssrc() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_ssrc(const std::string& value);
  std::string* _internal_mutable_ssrc();
  public:

  // string owner = 2;
  void clear_owner();
  const std::string& owner() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_owner(ArgT0&& arg0, ArgT... args);
  std::string* mutable_owner();
  PROTOBUF_NODISCARD std::string* release_owner();
  void set_allocated_owner(std::string* owner);
  private:
  const std::string& _internal_owner() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_owner(const std::string& value);
  std::string* _internal_mutable_owner();
  public:

  // @@protoc_insertion_point(class_scope:zorro.protobuf.Source)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::MapFieldLite<
      Source_ParametersEntry_DoNotUse,
      std::string, std::string,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> parameters_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr ssrc_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr owner_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_room_5fmessage_2eproto;
};
// -------------------------------------------------------------------

class SourceGroup final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:zorro.protobuf.SourceGroup) */ {
 public:
  inline SourceGroup() : SourceGroup(nullptr) {}
  ~SourceGroup() override;
  explicit constexpr SourceGroup(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SourceGroup(const SourceGroup& from);
  SourceGroup(SourceGroup&& from) noexcept
    : SourceGroup() {
    *this = ::std::move(from);
  }

  inline SourceGroup& operator=(const SourceGroup& from) {
    CopyFrom(from);
    return *this;
  }
  inline SourceGroup& operator=(SourceGroup&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const SourceGroup& default_instance() {
    return *internal_default_instance();
  }
  static inline const SourceGroup* internal_default_instance() {
    return reinterpret_cast<const SourceGroup*>(
               &_SourceGroup_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(SourceGroup& a, SourceGroup& b) {
    a.Swap(&b);
  }
  inline void Swap(SourceGroup* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SourceGroup* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SourceGroup* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SourceGroup>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const SourceGroup& from);
  void MergeFrom(const SourceGroup& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(SourceGroup* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "zorro.protobuf.SourceGroup";
  }
  protected:
  explicit SourceGroup(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSsrcFieldNumber = 2,
    kSemanticsFieldNumber = 1,
  };
  // repeated string ssrc = 2;
  int ssrc_size() const;
  private:
  int _internal_ssrc_size() const;
  public:
  void clear_ssrc();
  const std::string& ssrc(int index) const;
  std::string* mutable_ssrc(int index);
  void set_ssrc(int index, const std::string& value);
  void set_ssrc(int index, std::string&& value);
  void set_ssrc(int index, const char* value);
  void set_ssrc(int index, const char* value, size_t size);
  std::string* add_ssrc();
  void add_ssrc(const std::string& value);
  void add_ssrc(std::string&& value);
  void add_ssrc(const char* value);
  void add_ssrc(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& ssrc() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_ssrc();
  private:
  const std::string& _internal_ssrc(int index) const;
  std::string* _internal_add_ssrc();
  public:

  // string semantics = 1;
  void clear_semantics();
  const std::string& semantics() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_semantics(ArgT0&& arg0, ArgT... args);
  std::string* mutable_semantics();
  PROTOBUF_NODISCARD std::string* release_semantics();
  void set_allocated_semantics(std::string* semantics);
  private:
  const std::string& _internal_semantics() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_semantics(const std::string& value);
  std::string* _internal_mutable_semantics();
  public:

  // @@protoc_insertion_point(class_scope:zorro.protobuf.SourceGroup)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> ssrc_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr semantics_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_room_5fmessage_2eproto;
};
// -------------------------------------------------------------------

class Description final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:zorro.protobuf.Description) */ {
 public:
  inline Description() : Description(nullptr) {}
  ~Description() override;
  explicit constexpr Description(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Description(const Description& from);
  Description(Description&& from) noexcept
    : Description() {
    *this = ::std::move(from);
  }

  inline Description& operator=(const Description& from) {
    CopyFrom(from);
    return *this;
  }
  inline Description& operator=(Description&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const Description& default_instance() {
    return *internal_default_instance();
  }
  static inline const Description* internal_default_instance() {
    return reinterpret_cast<const Description*>(
               &_Description_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(Description& a, Description& b) {
    a.Swap(&b);
  }
  inline void Swap(Description* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Description* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Description* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Description>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const Description& from);
  void MergeFrom(const Description& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Description* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "zorro.protobuf.Description";
  }
  protected:
  explicit Description(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPayloadTypeFieldNumber = 3,
    kRtpHdrExtFieldNumber = 4,
    kSourceFieldNumber = 6,
    kSourceGroupFieldNumber = 7,
    kMediaFieldNumber = 1,
    kMaxptimeFieldNumber = 2,
    kRtcpMuxFieldNumber = 5,
  };
  // repeated .zorro.protobuf.PayloadType payloadType = 3;
  int payloadtype_size() const;
  private:
  int _internal_payloadtype_size() const;
  public:
  void clear_payloadtype();
  ::zorro::protobuf::PayloadType* mutable_payloadtype(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zorro::protobuf::PayloadType >*
      mutable_payloadtype();
  private:
  const ::zorro::protobuf::PayloadType& _internal_payloadtype(int index) const;
  ::zorro::protobuf::PayloadType* _internal_add_payloadtype();
  public:
  const ::zorro::protobuf::PayloadType& payloadtype(int index) const;
  ::zorro::protobuf::PayloadType* add_payloadtype();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zorro::protobuf::PayloadType >&
      payloadtype() const;

  // repeated .zorro.protobuf.RtpHdrExt rtpHdrExt = 4;
  int rtphdrext_size() const;
  private:
  int _internal_rtphdrext_size() const;
  public:
  void clear_rtphdrext();
  ::zorro::protobuf::RtpHdrExt* mutable_rtphdrext(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zorro::protobuf::RtpHdrExt >*
      mutable_rtphdrext();
  private:
  const ::zorro::protobuf::RtpHdrExt& _internal_rtphdrext(int index) const;
  ::zorro::protobuf::RtpHdrExt* _internal_add_rtphdrext();
  public:
  const ::zorro::protobuf::RtpHdrExt& rtphdrext(int index) const;
  ::zorro::protobuf::RtpHdrExt* add_rtphdrext();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zorro::protobuf::RtpHdrExt >&
      rtphdrext() const;

  // repeated .zorro.protobuf.Source source = 6;
  int source_size() const;
  private:
  int _internal_source_size() const;
  public:
  void clear_source();
  ::zorro::protobuf::Source* mutable_source(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zorro::protobuf::Source >*
      mutable_source();
  private:
  const ::zorro::protobuf::Source& _internal_source(int index) const;
  ::zorro::protobuf::Source* _internal_add_source();
  public:
  const ::zorro::protobuf::Source& source(int index) const;
  ::zorro::protobuf::Source* add_source();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zorro::protobuf::Source >&
      source() const;

  // repeated .zorro.protobuf.SourceGroup sourceGroup = 7;
  int sourcegroup_size() const;
  private:
  int _internal_sourcegroup_size() const;
  public:
  void clear_sourcegroup();
  ::zorro::protobuf::SourceGroup* mutable_sourcegroup(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zorro::protobuf::SourceGroup >*
      mutable_sourcegroup();
  private:
  const ::zorro::protobuf::SourceGroup& _internal_sourcegroup(int index) const;
  ::zorro::protobuf::SourceGroup* _internal_add_sourcegroup();
  public:
  const ::zorro::protobuf::SourceGroup& sourcegroup(int index) const;
  ::zorro::protobuf::SourceGroup* add_sourcegroup();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zorro::protobuf::SourceGroup >&
      sourcegroup() const;

  // string media = 1;
  void clear_media();
  const std::string& media() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_media(ArgT0&& arg0, ArgT... args);
  std::string* mutable_media();
  PROTOBUF_NODISCARD std::string* release_media();
  void set_allocated_media(std::string* media);
  private:
  const std::string& _internal_media() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_media(const std::string& value);
  std::string* _internal_mutable_media();
  public:

  // int32 maxptime = 2;
  void clear_maxptime();
  int32_t maxptime() const;
  void set_maxptime(int32_t value);
  private:
  int32_t _internal_maxptime() const;
  void _internal_set_maxptime(int32_t value);
  public:

  // bool rtcpMux = 5;
  void clear_rtcpmux();
  bool rtcpmux() const;
  void set_rtcpmux(bool value);
  private:
  bool _internal_rtcpmux() const;
  void _internal_set_rtcpmux(bool value);
  public:

  // @@protoc_insertion_point(class_scope:zorro.protobuf.Description)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zorro::protobuf::PayloadType > payloadtype_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zorro::protobuf::RtpHdrExt > rtphdrext_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zorro::protobuf::Source > source_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zorro::protobuf::SourceGroup > sourcegroup_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr media_;
  int32_t maxptime_;
  bool rtcpmux_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_room_5fmessage_2eproto;
};
// -------------------------------------------------------------------

class Fingerprint final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:zorro.protobuf.Fingerprint) */ {
 public:
  inline Fingerprint() : Fingerprint(nullptr) {}
  ~Fingerprint() override;
  explicit constexpr Fingerprint(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Fingerprint(const Fingerprint& from);
  Fingerprint(Fingerprint&& from) noexcept
    : Fingerprint() {
    *this = ::std::move(from);
  }

  inline Fingerprint& operator=(const Fingerprint& from) {
    CopyFrom(from);
    return *this;
  }
  inline Fingerprint& operator=(Fingerprint&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const Fingerprint& default_instance() {
    return *internal_default_instance();
  }
  static inline const Fingerprint* internal_default_instance() {
    return reinterpret_cast<const Fingerprint*>(
               &_Fingerprint_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(Fingerprint& a, Fingerprint& b) {
    a.Swap(&b);
  }
  inline void Swap(Fingerprint* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Fingerprint* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Fingerprint* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Fingerprint>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const Fingerprint& from);
  void MergeFrom(const Fingerprint& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Fingerprint* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "zorro.protobuf.Fingerprint";
  }
  protected:
  explicit Fingerprint(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHashTypeFieldNumber = 1,
    kSetupFieldNumber = 3,
    kValueFieldNumber = 4,
    kRequiredFieldNumber = 2,
  };
  // string hashType = 1;
  void clear_hashtype();
  const std::string& hashtype() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_hashtype(ArgT0&& arg0, ArgT... args);
  std::string* mutable_hashtype();
  PROTOBUF_NODISCARD std::string* release_hashtype();
  void set_allocated_hashtype(std::string* hashtype);
  private:
  const std::string& _internal_hashtype() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_hashtype(const std::string& value);
  std::string* _internal_mutable_hashtype();
  public:

  // string setup = 3;
  void clear_setup();
  const std::string& setup() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_setup(ArgT0&& arg0, ArgT... args);
  std::string* mutable_setup();
  PROTOBUF_NODISCARD std::string* release_setup();
  void set_allocated_setup(std::string* setup);
  private:
  const std::string& _internal_setup() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_setup(const std::string& value);
  std::string* _internal_mutable_setup();
  public:

  // string value = 4;
  void clear_value();
  const std::string& value() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_value(ArgT0&& arg0, ArgT... args);
  std::string* mutable_value();
  PROTOBUF_NODISCARD std::string* release_value();
  void set_allocated_value(std::string* value);
  private:
  const std::string& _internal_value() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_value(const std::string& value);
  std::string* _internal_mutable_value();
  public:

  // bool required = 2;
  void clear_required();
  bool required() const;
  void set_required(bool value);
  private:
  bool _internal_required() const;
  void _internal_set_required(bool value);
  public:

  // @@protoc_insertion_point(class_scope:zorro.protobuf.Fingerprint)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr hashtype_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr setup_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr value_;
  bool required_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_room_5fmessage_2eproto;
};
// -------------------------------------------------------------------

class Crypto final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:zorro.protobuf.Crypto) */ {
 public:
  inline Crypto() : Crypto(nullptr) {}
  ~Crypto() override;
  explicit constexpr Crypto(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Crypto(const Crypto& from);
  Crypto(Crypto&& from) noexcept
    : Crypto() {
    *this = ::std::move(from);
  }

  inline Crypto& operator=(const Crypto& from) {
    CopyFrom(from);
    return *this;
  }
  inline Crypto& operator=(Crypto&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const Crypto& default_instance() {
    return *internal_default_instance();
  }
  static inline const Crypto* internal_default_instance() {
    return reinterpret_cast<const Crypto*>(
               &_Crypto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(Crypto& a, Crypto& b) {
    a.Swap(&b);
  }
  inline void Swap(Crypto* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Crypto* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Crypto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Crypto>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const Crypto& from);
  void MergeFrom(const Crypto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Crypto* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "zorro.protobuf.Crypto";
  }
  protected:
  explicit Crypto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTagFieldNumber = 1,
    kSuiteFieldNumber = 2,
    kKeyParamsFieldNumber = 3,
    kSessParamsFieldNumber = 4,
  };
  // string tag = 1;
  void clear_tag();
  const std::string& tag() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_tag(ArgT0&& arg0, ArgT... args);
  std::string* mutable_tag();
  PROTOBUF_NODISCARD std::string* release_tag();
  void set_allocated_tag(std::string* tag);
  private:
  const std::string& _internal_tag() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_tag(const std::string& value);
  std::string* _internal_mutable_tag();
  public:

  // string suite = 2;
  void clear_suite();
  const std::string& suite() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_suite(ArgT0&& arg0, ArgT... args);
  std::string* mutable_suite();
  PROTOBUF_NODISCARD std::string* release_suite();
  void set_allocated_suite(std::string* suite);
  private:
  const std::string& _internal_suite() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_suite(const std::string& value);
  std::string* _internal_mutable_suite();
  public:

  // string keyParams = 3;
  void clear_keyparams();
  const std::string& keyparams() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_keyparams(ArgT0&& arg0, ArgT... args);
  std::string* mutable_keyparams();
  PROTOBUF_NODISCARD std::string* release_keyparams();
  void set_allocated_keyparams(std::string* keyparams);
  private:
  const std::string& _internal_keyparams() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_keyparams(const std::string& value);
  std::string* _internal_mutable_keyparams();
  public:

  // string sessParams = 4;
  void clear_sessparams();
  const std::string& sessparams() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_sessparams(ArgT0&& arg0, ArgT... args);
  std::string* mutable_sessparams();
  PROTOBUF_NODISCARD std::string* release_sessparams();
  void set_allocated_sessparams(std::string* sessparams);
  private:
  const std::string& _internal_sessparams() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_sessparams(const std::string& value);
  std::string* _internal_mutable_sessparams();
  public:

  // @@protoc_insertion_point(class_scope:zorro.protobuf.Crypto)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr tag_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr suite_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr keyparams_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr sessparams_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_room_5fmessage_2eproto;
};
// -------------------------------------------------------------------

class Candidate final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:zorro.protobuf.Candidate) */ {
 public:
  inline Candidate() : Candidate(nullptr) {}
  ~Candidate() override;
  explicit constexpr Candidate(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Candidate(const Candidate& from);
  Candidate(Candidate&& from) noexcept
    : Candidate() {
    *this = ::std::move(from);
  }

  inline Candidate& operator=(const Candidate& from) {
    CopyFrom(from);
    return *this;
  }
  inline Candidate& operator=(Candidate&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const Candidate& default_instance() {
    return *internal_default_instance();
  }
  static inline const Candidate* internal_default_instance() {
    return reinterpret_cast<const Candidate*>(
               &_Candidate_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(Candidate& a, Candidate& b) {
    a.Swap(&b);
  }
  inline void Swap(Candidate* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Candidate* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Candidate* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Candidate>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const Candidate& from);
  void MergeFrom(const Candidate& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Candidate* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "zorro.protobuf.Candidate";
  }
  protected:
  explicit Candidate(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFoundationFieldNumber = 2,
    kIdFieldNumber = 4,
    kProtocolFieldNumber = 7,
    kTcptypeFieldNumber = 8,
    kTypeFieldNumber = 9,
    kIpFieldNumber = 10,
    kDomainFieldNumber = 11,
    kRealAddrFieldNumber = 13,
    kComponentFieldNumber = 1,
    kGenerationFieldNumber = 3,
    kPriorityFieldNumber = 6,
    kNetworkFieldNumber = 5,
    kPortFieldNumber = 12,
    kRealPortFieldNumber = 14,
  };
  // string foundation = 2;
  void clear_foundation();
  const std::string& foundation() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_foundation(ArgT0&& arg0, ArgT... args);
  std::string* mutable_foundation();
  PROTOBUF_NODISCARD std::string* release_foundation();
  void set_allocated_foundation(std::string* foundation);
  private:
  const std::string& _internal_foundation() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_foundation(const std::string& value);
  std::string* _internal_mutable_foundation();
  public:

  // string id = 4;
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // string protocol = 7;
  void clear_protocol();
  const std::string& protocol() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_protocol(ArgT0&& arg0, ArgT... args);
  std::string* mutable_protocol();
  PROTOBUF_NODISCARD std::string* release_protocol();
  void set_allocated_protocol(std::string* protocol);
  private:
  const std::string& _internal_protocol() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_protocol(const std::string& value);
  std::string* _internal_mutable_protocol();
  public:

  // string tcptype = 8;
  void clear_tcptype();
  const std::string& tcptype() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_tcptype(ArgT0&& arg0, ArgT... args);
  std::string* mutable_tcptype();
  PROTOBUF_NODISCARD std::string* release_tcptype();
  void set_allocated_tcptype(std::string* tcptype);
  private:
  const std::string& _internal_tcptype() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_tcptype(const std::string& value);
  std::string* _internal_mutable_tcptype();
  public:

  // string type = 9;
  void clear_type();
  const std::string& type() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_type(ArgT0&& arg0, ArgT... args);
  std::string* mutable_type();
  PROTOBUF_NODISCARD std::string* release_type();
  void set_allocated_type(std::string* type);
  private:
  const std::string& _internal_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_type(const std::string& value);
  std::string* _internal_mutable_type();
  public:

  // string ip = 10;
  void clear_ip();
  const std::string& ip() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_ip(ArgT0&& arg0, ArgT... args);
  std::string* mutable_ip();
  PROTOBUF_NODISCARD std::string* release_ip();
  void set_allocated_ip(std::string* ip);
  private:
  const std::string& _internal_ip() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_ip(const std::string& value);
  std::string* _internal_mutable_ip();
  public:

  // string domain = 11;
  void clear_domain();
  const std::string& domain() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_domain(ArgT0&& arg0, ArgT... args);
  std::string* mutable_domain();
  PROTOBUF_NODISCARD std::string* release_domain();
  void set_allocated_domain(std::string* domain);
  private:
  const std::string& _internal_domain() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_domain(const std::string& value);
  std::string* _internal_mutable_domain();
  public:

  // string realAddr = 13;
  void clear_realaddr();
  const std::string& realaddr() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_realaddr(ArgT0&& arg0, ArgT... args);
  std::string* mutable_realaddr();
  PROTOBUF_NODISCARD std::string* release_realaddr();
  void set_allocated_realaddr(std::string* realaddr);
  private:
  const std::string& _internal_realaddr() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_realaddr(const std::string& value);
  std::string* _internal_mutable_realaddr();
  public:

  // int32 component = 1;
  void clear_component();
  int32_t component() const;
  void set_component(int32_t value);
  private:
  int32_t _internal_component() const;
  void _internal_set_component(int32_t value);
  public:

  // int32 generation = 3;
  void clear_generation();
  int32_t generation() const;
  void set_generation(int32_t value);
  private:
  int32_t _internal_generation() const;
  void _internal_set_generation(int32_t value);
  public:

  // int64 priority = 6;
  void clear_priority();
  int64_t priority() const;
  void set_priority(int64_t value);
  private:
  int64_t _internal_priority() const;
  void _internal_set_priority(int64_t value);
  public:

  // int32 network = 5;
  void clear_network();
  int32_t network() const;
  void set_network(int32_t value);
  private:
  int32_t _internal_network() const;
  void _internal_set_network(int32_t value);
  public:

  // int32 port = 12;
  void clear_port();
  int32_t port() const;
  void set_port(int32_t value);
  private:
  int32_t _internal_port() const;
  void _internal_set_port(int32_t value);
  public:

  // int32 realPort = 14;
  void clear_realport();
  int32_t realport() const;
  void set_realport(int32_t value);
  private:
  int32_t _internal_realport() const;
  void _internal_set_realport(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:zorro.protobuf.Candidate)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr foundation_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr protocol_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr tcptype_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr type_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr ip_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr domain_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr realaddr_;
  int32_t component_;
  int32_t generation_;
  int64_t priority_;
  int32_t network_;
  int32_t port_;
  int32_t realport_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_room_5fmessage_2eproto;
};
// -------------------------------------------------------------------

class Transport final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:zorro.protobuf.Transport) */ {
 public:
  inline Transport() : Transport(nullptr) {}
  ~Transport() override;
  explicit constexpr Transport(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Transport(const Transport& from);
  Transport(Transport&& from) noexcept
    : Transport() {
    *this = ::std::move(from);
  }

  inline Transport& operator=(const Transport& from) {
    CopyFrom(from);
    return *this;
  }
  inline Transport& operator=(Transport&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const Transport& default_instance() {
    return *internal_default_instance();
  }
  static inline const Transport* internal_default_instance() {
    return reinterpret_cast<const Transport*>(
               &_Transport_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(Transport& a, Transport& b) {
    a.Swap(&b);
  }
  inline void Swap(Transport* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Transport* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Transport* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Transport>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const Transport& from);
  void MergeFrom(const Transport& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Transport* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "zorro.protobuf.Transport";
  }
  protected:
  explicit Transport(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCandidatesFieldNumber = 5,
    kUfragFieldNumber = 1,
    kPwdFieldNumber = 2,
    kFingerprintFieldNumber = 4,
    kCryptoFieldNumber = 6,
    kRtcpMuxFieldNumber = 3,
  };
  // repeated .zorro.protobuf.Candidate candidates = 5;
  int candidates_size() const;
  private:
  int _internal_candidates_size() const;
  public:
  void clear_candidates();
  ::zorro::protobuf::Candidate* mutable_candidates(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zorro::protobuf::Candidate >*
      mutable_candidates();
  private:
  const ::zorro::protobuf::Candidate& _internal_candidates(int index) const;
  ::zorro::protobuf::Candidate* _internal_add_candidates();
  public:
  const ::zorro::protobuf::Candidate& candidates(int index) const;
  ::zorro::protobuf::Candidate* add_candidates();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zorro::protobuf::Candidate >&
      candidates() const;

  // string ufrag = 1;
  void clear_ufrag();
  const std::string& ufrag() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_ufrag(ArgT0&& arg0, ArgT... args);
  std::string* mutable_ufrag();
  PROTOBUF_NODISCARD std::string* release_ufrag();
  void set_allocated_ufrag(std::string* ufrag);
  private:
  const std::string& _internal_ufrag() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_ufrag(const std::string& value);
  std::string* _internal_mutable_ufrag();
  public:

  // string pwd = 2;
  void clear_pwd();
  const std::string& pwd() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_pwd(ArgT0&& arg0, ArgT... args);
  std::string* mutable_pwd();
  PROTOBUF_NODISCARD std::string* release_pwd();
  void set_allocated_pwd(std::string* pwd);
  private:
  const std::string& _internal_pwd() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_pwd(const std::string& value);
  std::string* _internal_mutable_pwd();
  public:

  // .zorro.protobuf.Fingerprint fingerprint = 4;
  bool has_fingerprint() const;
  private:
  bool _internal_has_fingerprint() const;
  public:
  void clear_fingerprint();
  const ::zorro::protobuf::Fingerprint& fingerprint() const;
  PROTOBUF_NODISCARD ::zorro::protobuf::Fingerprint* release_fingerprint();
  ::zorro::protobuf::Fingerprint* mutable_fingerprint();
  void set_allocated_fingerprint(::zorro::protobuf::Fingerprint* fingerprint);
  private:
  const ::zorro::protobuf::Fingerprint& _internal_fingerprint() const;
  ::zorro::protobuf::Fingerprint* _internal_mutable_fingerprint();
  public:
  void unsafe_arena_set_allocated_fingerprint(
      ::zorro::protobuf::Fingerprint* fingerprint);
  ::zorro::protobuf::Fingerprint* unsafe_arena_release_fingerprint();

  // .zorro.protobuf.Crypto crypto = 6;
  bool has_crypto() const;
  private:
  bool _internal_has_crypto() const;
  public:
  void clear_crypto();
  const ::zorro::protobuf::Crypto& crypto() const;
  PROTOBUF_NODISCARD ::zorro::protobuf::Crypto* release_crypto();
  ::zorro::protobuf::Crypto* mutable_crypto();
  void set_allocated_crypto(::zorro::protobuf::Crypto* crypto);
  private:
  const ::zorro::protobuf::Crypto& _internal_crypto() const;
  ::zorro::protobuf::Crypto* _internal_mutable_crypto();
  public:
  void unsafe_arena_set_allocated_crypto(
      ::zorro::protobuf::Crypto* crypto);
  ::zorro::protobuf::Crypto* unsafe_arena_release_crypto();

  // bool rtcpMux = 3;
  void clear_rtcpmux();
  bool rtcpmux() const;
  void set_rtcpmux(bool value);
  private:
  bool _internal_rtcpmux() const;
  void _internal_set_rtcpmux(bool value);
  public:

  // @@protoc_insertion_point(class_scope:zorro.protobuf.Transport)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zorro::protobuf::Candidate > candidates_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr ufrag_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr pwd_;
  ::zorro::protobuf::Fingerprint* fingerprint_;
  ::zorro::protobuf::Crypto* crypto_;
  bool rtcpmux_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_room_5fmessage_2eproto;
};
// -------------------------------------------------------------------

class Content final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:zorro.protobuf.Content) */ {
 public:
  inline Content() : Content(nullptr) {}
  ~Content() override;
  explicit constexpr Content(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Content(const Content& from);
  Content(Content&& from) noexcept
    : Content() {
    *this = ::std::move(from);
  }

  inline Content& operator=(const Content& from) {
    CopyFrom(from);
    return *this;
  }
  inline Content& operator=(Content&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const Content& default_instance() {
    return *internal_default_instance();
  }
  static inline const Content* internal_default_instance() {
    return reinterpret_cast<const Content*>(
               &_Content_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(Content& a, Content& b) {
    a.Swap(&b);
  }
  inline void Swap(Content* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Content* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Content* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Content>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const Content& from);
  void MergeFrom(const Content& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Content* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "zorro.protobuf.Content";
  }
  protected:
  explicit Content(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCreatorFieldNumber = 1,
    kNameFieldNumber = 2,
    kSendersFieldNumber = 3,
    kDescriptionFieldNumber = 4,
    kTransportFieldNumber = 5,
  };
  // string creator = 1;
  void clear_creator();
  const std::string& creator() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_creator(ArgT0&& arg0, ArgT... args);
  std::string* mutable_creator();
  PROTOBUF_NODISCARD std::string* release_creator();
  void set_allocated_creator(std::string* creator);
  private:
  const std::string& _internal_creator() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_creator(const std::string& value);
  std::string* _internal_mutable_creator();
  public:

  // string name = 2;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string senders = 3;
  void clear_senders();
  const std::string& senders() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_senders(ArgT0&& arg0, ArgT... args);
  std::string* mutable_senders();
  PROTOBUF_NODISCARD std::string* release_senders();
  void set_allocated_senders(std::string* senders);
  private:
  const std::string& _internal_senders() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_senders(const std::string& value);
  std::string* _internal_mutable_senders();
  public:

  // .zorro.protobuf.Description description = 4;
  bool has_description() const;
  private:
  bool _internal_has_description() const;
  public:
  void clear_description();
  const ::zorro::protobuf::Description& description() const;
  PROTOBUF_NODISCARD ::zorro::protobuf::Description* release_description();
  ::zorro::protobuf::Description* mutable_description();
  void set_allocated_description(::zorro::protobuf::Description* description);
  private:
  const ::zorro::protobuf::Description& _internal_description() const;
  ::zorro::protobuf::Description* _internal_mutable_description();
  public:
  void unsafe_arena_set_allocated_description(
      ::zorro::protobuf::Description* description);
  ::zorro::protobuf::Description* unsafe_arena_release_description();

  // .zorro.protobuf.Transport transport = 5;
  bool has_transport() const;
  private:
  bool _internal_has_transport() const;
  public:
  void clear_transport();
  const ::zorro::protobuf::Transport& transport() const;
  PROTOBUF_NODISCARD ::zorro::protobuf::Transport* release_transport();
  ::zorro::protobuf::Transport* mutable_transport();
  void set_allocated_transport(::zorro::protobuf::Transport* transport);
  private:
  const ::zorro::protobuf::Transport& _internal_transport() const;
  ::zorro::protobuf::Transport* _internal_mutable_transport();
  public:
  void unsafe_arena_set_allocated_transport(
      ::zorro::protobuf::Transport* transport);
  ::zorro::protobuf::Transport* unsafe_arena_release_transport();

  // @@protoc_insertion_point(class_scope:zorro.protobuf.Content)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr creator_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr senders_;
  ::zorro::protobuf::Description* description_;
  ::zorro::protobuf::Transport* transport_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_room_5fmessage_2eproto;
};
// -------------------------------------------------------------------

class SDP final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:zorro.protobuf.SDP) */ {
 public:
  inline SDP() : SDP(nullptr) {}
  ~SDP() override;
  explicit constexpr SDP(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SDP(const SDP& from);
  SDP(SDP&& from) noexcept
    : SDP() {
    *this = ::std::move(from);
  }

  inline SDP& operator=(const SDP& from) {
    CopyFrom(from);
    return *this;
  }
  inline SDP& operator=(SDP&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const SDP& default_instance() {
    return *internal_default_instance();
  }
  static inline const SDP* internal_default_instance() {
    return reinterpret_cast<const SDP*>(
               &_SDP_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(SDP& a, SDP& b) {
    a.Swap(&b);
  }
  inline void Swap(SDP* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SDP* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SDP* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SDP>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const SDP& from);
  void MergeFrom(const SDP& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(SDP* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "zorro.protobuf.SDP";
  }
  protected:
  explicit SDP(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kContentsFieldNumber = 1,
  };
  // repeated .zorro.protobuf.Content contents = 1;
  int contents_size() const;
  private:
  int _internal_contents_size() const;
  public:
  void clear_contents();
  ::zorro::protobuf::Content* mutable_contents(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zorro::protobuf::Content >*
      mutable_contents();
  private:
  const ::zorro::protobuf::Content& _internal_contents(int index) const;
  ::zorro::protobuf::Content* _internal_add_contents();
  public:
  const ::zorro::protobuf::Content& contents(int index) const;
  ::zorro::protobuf::Content* add_contents();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zorro::protobuf::Content >&
      contents() const;

  // @@protoc_insertion_point(class_scope:zorro.protobuf.SDP)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zorro::protobuf::Content > contents_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_room_5fmessage_2eproto;
};
// -------------------------------------------------------------------

class RoomMessage_ParameterMapEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntryLite<RoomMessage_ParameterMapEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntryLite<RoomMessage_ParameterMapEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> SuperType;
  RoomMessage_ParameterMapEntry_DoNotUse();
  explicit constexpr RoomMessage_ParameterMapEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit RoomMessage_ParameterMapEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const RoomMessage_ParameterMapEntry_DoNotUse& other);
  static const RoomMessage_ParameterMapEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const RoomMessage_ParameterMapEntry_DoNotUse*>(&_RoomMessage_ParameterMapEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "zorro.protobuf.RoomMessage.ParameterMapEntry.key");
 }
  static bool ValidateValue(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "zorro.protobuf.RoomMessage.ParameterMapEntry.value");
 }
};

// -------------------------------------------------------------------

class RoomMessage final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:zorro.protobuf.RoomMessage) */ {
 public:
  inline RoomMessage() : RoomMessage(nullptr) {}
  ~RoomMessage() override;
  explicit constexpr RoomMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RoomMessage(const RoomMessage& from);
  RoomMessage(RoomMessage&& from) noexcept
    : RoomMessage() {
    *this = ::std::move(from);
  }

  inline RoomMessage& operator=(const RoomMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline RoomMessage& operator=(RoomMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const RoomMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const RoomMessage* internal_default_instance() {
    return reinterpret_cast<const RoomMessage*>(
               &_RoomMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(RoomMessage& a, RoomMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(RoomMessage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RoomMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RoomMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RoomMessage>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const RoomMessage& from);
  void MergeFrom(const RoomMessage& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(RoomMessage* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "zorro.protobuf.RoomMessage";
  }
  protected:
  explicit RoomMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kParameterMapFieldNumber = 7,
    kParameterListFieldNumber = 8,
    kActionFieldNumber = 1,
    kUserIdFieldNumber = 2,
    kRoomIdFieldNumber = 3,
    kRegionFieldNumber = 4,
    kServerTopicFieldNumber = 5,
    kUserTopicFieldNumber = 6,
    kSdpFieldNumber = 9,
  };
  // map<string, string> parameterMap = 7;
  int parametermap_size() const;
  private:
  int _internal_parametermap_size() const;
  public:
  void clear_parametermap();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      _internal_parametermap() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      _internal_mutable_parametermap();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      parametermap() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      mutable_parametermap();

  // repeated string parameterList = 8;
  int parameterlist_size() const;
  private:
  int _internal_parameterlist_size() const;
  public:
  void clear_parameterlist();
  const std::string& parameterlist(int index) const;
  std::string* mutable_parameterlist(int index);
  void set_parameterlist(int index, const std::string& value);
  void set_parameterlist(int index, std::string&& value);
  void set_parameterlist(int index, const char* value);
  void set_parameterlist(int index, const char* value, size_t size);
  std::string* add_parameterlist();
  void add_parameterlist(const std::string& value);
  void add_parameterlist(std::string&& value);
  void add_parameterlist(const char* value);
  void add_parameterlist(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& parameterlist() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_parameterlist();
  private:
  const std::string& _internal_parameterlist(int index) const;
  std::string* _internal_add_parameterlist();
  public:

  // string action = 1;
  void clear_action();
  const std::string& action() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_action(ArgT0&& arg0, ArgT... args);
  std::string* mutable_action();
  PROTOBUF_NODISCARD std::string* release_action();
  void set_allocated_action(std::string* action);
  private:
  const std::string& _internal_action() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_action(const std::string& value);
  std::string* _internal_mutable_action();
  public:

  // string userId = 2;
  void clear_userid();
  const std::string& userid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_userid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_userid();
  PROTOBUF_NODISCARD std::string* release_userid();
  void set_allocated_userid(std::string* userid);
  private:
  const std::string& _internal_userid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_userid(const std::string& value);
  std::string* _internal_mutable_userid();
  public:

  // string roomId = 3;
  void clear_roomid();
  const std::string& roomid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_roomid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_roomid();
  PROTOBUF_NODISCARD std::string* release_roomid();
  void set_allocated_roomid(std::string* roomid);
  private:
  const std::string& _internal_roomid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_roomid(const std::string& value);
  std::string* _internal_mutable_roomid();
  public:

  // string region = 4;
  void clear_region();
  const std::string& region() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_region(ArgT0&& arg0, ArgT... args);
  std::string* mutable_region();
  PROTOBUF_NODISCARD std::string* release_region();
  void set_allocated_region(std::string* region);
  private:
  const std::string& _internal_region() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_region(const std::string& value);
  std::string* _internal_mutable_region();
  public:

  // string serverTopic = 5;
  void clear_servertopic();
  const std::string& servertopic() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_servertopic(ArgT0&& arg0, ArgT... args);
  std::string* mutable_servertopic();
  PROTOBUF_NODISCARD std::string* release_servertopic();
  void set_allocated_servertopic(std::string* servertopic);
  private:
  const std::string& _internal_servertopic() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_servertopic(const std::string& value);
  std::string* _internal_mutable_servertopic();
  public:

  // string userTopic = 6;
  void clear_usertopic();
  const std::string& usertopic() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_usertopic(ArgT0&& arg0, ArgT... args);
  std::string* mutable_usertopic();
  PROTOBUF_NODISCARD std::string* release_usertopic();
  void set_allocated_usertopic(std::string* usertopic);
  private:
  const std::string& _internal_usertopic() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_usertopic(const std::string& value);
  std::string* _internal_mutable_usertopic();
  public:

  // .zorro.protobuf.SDP sdp = 9;
  bool has_sdp() const;
  private:
  bool _internal_has_sdp() const;
  public:
  void clear_sdp();
  const ::zorro::protobuf::SDP& sdp() const;
  PROTOBUF_NODISCARD ::zorro::protobuf::SDP* release_sdp();
  ::zorro::protobuf::SDP* mutable_sdp();
  void set_allocated_sdp(::zorro::protobuf::SDP* sdp);
  private:
  const ::zorro::protobuf::SDP& _internal_sdp() const;
  ::zorro::protobuf::SDP* _internal_mutable_sdp();
  public:
  void unsafe_arena_set_allocated_sdp(
      ::zorro::protobuf::SDP* sdp);
  ::zorro::protobuf::SDP* unsafe_arena_release_sdp();

  // @@protoc_insertion_point(class_scope:zorro.protobuf.RoomMessage)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::MapFieldLite<
      RoomMessage_ParameterMapEntry_DoNotUse,
      std::string, std::string,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> parametermap_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> parameterlist_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr action_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr userid_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr roomid_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr region_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr servertopic_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr usertopic_;
  ::zorro::protobuf::SDP* sdp_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_room_5fmessage_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// RtpHdrExt

// string id = 1;
inline void RtpHdrExt::clear_id() {
  id_.ClearToEmpty();
}
inline const std::string& RtpHdrExt::id() const {
  // @@protoc_insertion_point(field_get:zorro.protobuf.RtpHdrExt.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RtpHdrExt::set_id(ArgT0&& arg0, ArgT... args) {
 
 id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:zorro.protobuf.RtpHdrExt.id)
}
inline std::string* RtpHdrExt::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:zorro.protobuf.RtpHdrExt.id)
  return _s;
}
inline const std::string& RtpHdrExt::_internal_id() const {
  return id_.Get();
}
inline void RtpHdrExt::_internal_set_id(const std::string& value) {
  
  id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* RtpHdrExt::_internal_mutable_id() {
  
  return id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* RtpHdrExt::release_id() {
  // @@protoc_insertion_point(field_release:zorro.protobuf.RtpHdrExt.id)
  return id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void RtpHdrExt::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), id,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:zorro.protobuf.RtpHdrExt.id)
}

// string uri = 2;
inline void RtpHdrExt::clear_uri() {
  uri_.ClearToEmpty();
}
inline const std::string& RtpHdrExt::uri() const {
  // @@protoc_insertion_point(field_get:zorro.protobuf.RtpHdrExt.uri)
  return _internal_uri();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RtpHdrExt::set_uri(ArgT0&& arg0, ArgT... args) {
 
 uri_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:zorro.protobuf.RtpHdrExt.uri)
}
inline std::string* RtpHdrExt::mutable_uri() {
  std::string* _s = _internal_mutable_uri();
  // @@protoc_insertion_point(field_mutable:zorro.protobuf.RtpHdrExt.uri)
  return _s;
}
inline const std::string& RtpHdrExt::_internal_uri() const {
  return uri_.Get();
}
inline void RtpHdrExt::_internal_set_uri(const std::string& value) {
  
  uri_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* RtpHdrExt::_internal_mutable_uri() {
  
  return uri_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* RtpHdrExt::release_uri() {
  // @@protoc_insertion_point(field_release:zorro.protobuf.RtpHdrExt.uri)
  return uri_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void RtpHdrExt::set_allocated_uri(std::string* uri) {
  if (uri != nullptr) {
    
  } else {
    
  }
  uri_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), uri,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (uri_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    uri_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:zorro.protobuf.RtpHdrExt.uri)
}

// -------------------------------------------------------------------

// RtcpFBType

// string type = 1;
inline void RtcpFBType::clear_type() {
  type_.ClearToEmpty();
}
inline const std::string& RtcpFBType::type() const {
  // @@protoc_insertion_point(field_get:zorro.protobuf.RtcpFBType.type)
  return _internal_type();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RtcpFBType::set_type(ArgT0&& arg0, ArgT... args) {
 
 type_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:zorro.protobuf.RtcpFBType.type)
}
inline std::string* RtcpFBType::mutable_type() {
  std::string* _s = _internal_mutable_type();
  // @@protoc_insertion_point(field_mutable:zorro.protobuf.RtcpFBType.type)
  return _s;
}
inline const std::string& RtcpFBType::_internal_type() const {
  return type_.Get();
}
inline void RtcpFBType::_internal_set_type(const std::string& value) {
  
  type_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* RtcpFBType::_internal_mutable_type() {
  
  return type_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* RtcpFBType::release_type() {
  // @@protoc_insertion_point(field_release:zorro.protobuf.RtcpFBType.type)
  return type_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void RtcpFBType::set_allocated_type(std::string* type) {
  if (type != nullptr) {
    
  } else {
    
  }
  type_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), type,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (type_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    type_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:zorro.protobuf.RtcpFBType.type)
}

// string subType = 2;
inline void RtcpFBType::clear_subtype() {
  subtype_.ClearToEmpty();
}
inline const std::string& RtcpFBType::subtype() const {
  // @@protoc_insertion_point(field_get:zorro.protobuf.RtcpFBType.subType)
  return _internal_subtype();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RtcpFBType::set_subtype(ArgT0&& arg0, ArgT... args) {
 
 subtype_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:zorro.protobuf.RtcpFBType.subType)
}
inline std::string* RtcpFBType::mutable_subtype() {
  std::string* _s = _internal_mutable_subtype();
  // @@protoc_insertion_point(field_mutable:zorro.protobuf.RtcpFBType.subType)
  return _s;
}
inline const std::string& RtcpFBType::_internal_subtype() const {
  return subtype_.Get();
}
inline void RtcpFBType::_internal_set_subtype(const std::string& value) {
  
  subtype_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* RtcpFBType::_internal_mutable_subtype() {
  
  return subtype_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* RtcpFBType::release_subtype() {
  // @@protoc_insertion_point(field_release:zorro.protobuf.RtcpFBType.subType)
  return subtype_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void RtcpFBType::set_allocated_subtype(std::string* subtype) {
  if (subtype != nullptr) {
    
  } else {
    
  }
  subtype_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), subtype,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (subtype_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    subtype_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:zorro.protobuf.RtcpFBType.subType)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// PayloadType

// int32 id = 1;
inline void PayloadType::clear_id() {
  id_ = 0;
}
inline int32_t PayloadType::_internal_id() const {
  return id_;
}
inline int32_t PayloadType::id() const {
  // @@protoc_insertion_point(field_get:zorro.protobuf.PayloadType.id)
  return _internal_id();
}
inline void PayloadType::_internal_set_id(int32_t value) {
  
  id_ = value;
}
inline void PayloadType::set_id(int32_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:zorro.protobuf.PayloadType.id)
}

// string name = 2;
inline void PayloadType::clear_name() {
  name_.ClearToEmpty();
}
inline const std::string& PayloadType::name() const {
  // @@protoc_insertion_point(field_get:zorro.protobuf.PayloadType.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PayloadType::set_name(ArgT0&& arg0, ArgT... args) {
 
 name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:zorro.protobuf.PayloadType.name)
}
inline std::string* PayloadType::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:zorro.protobuf.PayloadType.name)
  return _s;
}
inline const std::string& PayloadType::_internal_name() const {
  return name_.Get();
}
inline void PayloadType::_internal_set_name(const std::string& value) {
  
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* PayloadType::_internal_mutable_name() {
  
  return name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* PayloadType::release_name() {
  // @@protoc_insertion_point(field_release:zorro.protobuf.PayloadType.name)
  return name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void PayloadType::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (name_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:zorro.protobuf.PayloadType.name)
}

// int32 clockrate = 3;
inline void PayloadType::clear_clockrate() {
  clockrate_ = 0;
}
inline int32_t PayloadType::_internal_clockrate() const {
  return clockrate_;
}
inline int32_t PayloadType::clockrate() const {
  // @@protoc_insertion_point(field_get:zorro.protobuf.PayloadType.clockrate)
  return _internal_clockrate();
}
inline void PayloadType::_internal_set_clockrate(int32_t value) {
  
  clockrate_ = value;
}
inline void PayloadType::set_clockrate(int32_t value) {
  _internal_set_clockrate(value);
  // @@protoc_insertion_point(field_set:zorro.protobuf.PayloadType.clockrate)
}

// int32 channels = 4;
inline void PayloadType::clear_channels() {
  channels_ = 0;
}
inline int32_t PayloadType::_internal_channels() const {
  return channels_;
}
inline int32_t PayloadType::channels() const {
  // @@protoc_insertion_point(field_get:zorro.protobuf.PayloadType.channels)
  return _internal_channels();
}
inline void PayloadType::_internal_set_channels(int32_t value) {
  
  channels_ = value;
}
inline void PayloadType::set_channels(int32_t value) {
  _internal_set_channels(value);
  // @@protoc_insertion_point(field_set:zorro.protobuf.PayloadType.channels)
}

// map<string, string> parameters = 5;
inline int PayloadType::_internal_parameters_size() const {
  return parameters_.size();
}
inline int PayloadType::parameters_size() const {
  return _internal_parameters_size();
}
inline void PayloadType::clear_parameters() {
  parameters_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
PayloadType::_internal_parameters() const {
  return parameters_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
PayloadType::parameters() const {
  // @@protoc_insertion_point(field_map:zorro.protobuf.PayloadType.parameters)
  return _internal_parameters();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
PayloadType::_internal_mutable_parameters() {
  return parameters_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
PayloadType::mutable_parameters() {
  // @@protoc_insertion_point(field_mutable_map:zorro.protobuf.PayloadType.parameters)
  return _internal_mutable_parameters();
}

// repeated .zorro.protobuf.RtcpFBType rtcpFb = 6;
inline int PayloadType::_internal_rtcpfb_size() const {
  return rtcpfb_.size();
}
inline int PayloadType::rtcpfb_size() const {
  return _internal_rtcpfb_size();
}
inline void PayloadType::clear_rtcpfb() {
  rtcpfb_.Clear();
}
inline ::zorro::protobuf::RtcpFBType* PayloadType::mutable_rtcpfb(int index) {
  // @@protoc_insertion_point(field_mutable:zorro.protobuf.PayloadType.rtcpFb)
  return rtcpfb_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zorro::protobuf::RtcpFBType >*
PayloadType::mutable_rtcpfb() {
  // @@protoc_insertion_point(field_mutable_list:zorro.protobuf.PayloadType.rtcpFb)
  return &rtcpfb_;
}
inline const ::zorro::protobuf::RtcpFBType& PayloadType::_internal_rtcpfb(int index) const {
  return rtcpfb_.Get(index);
}
inline const ::zorro::protobuf::RtcpFBType& PayloadType::rtcpfb(int index) const {
  // @@protoc_insertion_point(field_get:zorro.protobuf.PayloadType.rtcpFb)
  return _internal_rtcpfb(index);
}
inline ::zorro::protobuf::RtcpFBType* PayloadType::_internal_add_rtcpfb() {
  return rtcpfb_.Add();
}
inline ::zorro::protobuf::RtcpFBType* PayloadType::add_rtcpfb() {
  ::zorro::protobuf::RtcpFBType* _add = _internal_add_rtcpfb();
  // @@protoc_insertion_point(field_add:zorro.protobuf.PayloadType.rtcpFb)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zorro::protobuf::RtcpFBType >&
PayloadType::rtcpfb() const {
  // @@protoc_insertion_point(field_list:zorro.protobuf.PayloadType.rtcpFb)
  return rtcpfb_;
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// Source

// string ssrc = 1;
inline void Source::clear_ssrc() {
  ssrc_.ClearToEmpty();
}
inline const std::string& Source::ssrc() const {
  // @@protoc_insertion_point(field_get:zorro.protobuf.Source.ssrc)
  return _internal_ssrc();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Source::set_ssrc(ArgT0&& arg0, ArgT... args) {
 
 ssrc_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:zorro.protobuf.Source.ssrc)
}
inline std::string* Source::mutable_ssrc() {
  std::string* _s = _internal_mutable_ssrc();
  // @@protoc_insertion_point(field_mutable:zorro.protobuf.Source.ssrc)
  return _s;
}
inline const std::string& Source::_internal_ssrc() const {
  return ssrc_.Get();
}
inline void Source::_internal_set_ssrc(const std::string& value) {
  
  ssrc_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Source::_internal_mutable_ssrc() {
  
  return ssrc_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Source::release_ssrc() {
  // @@protoc_insertion_point(field_release:zorro.protobuf.Source.ssrc)
  return ssrc_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Source::set_allocated_ssrc(std::string* ssrc) {
  if (ssrc != nullptr) {
    
  } else {
    
  }
  ssrc_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ssrc,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (ssrc_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    ssrc_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:zorro.protobuf.Source.ssrc)
}

// string owner = 2;
inline void Source::clear_owner() {
  owner_.ClearToEmpty();
}
inline const std::string& Source::owner() const {
  // @@protoc_insertion_point(field_get:zorro.protobuf.Source.owner)
  return _internal_owner();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Source::set_owner(ArgT0&& arg0, ArgT... args) {
 
 owner_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:zorro.protobuf.Source.owner)
}
inline std::string* Source::mutable_owner() {
  std::string* _s = _internal_mutable_owner();
  // @@protoc_insertion_point(field_mutable:zorro.protobuf.Source.owner)
  return _s;
}
inline const std::string& Source::_internal_owner() const {
  return owner_.Get();
}
inline void Source::_internal_set_owner(const std::string& value) {
  
  owner_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Source::_internal_mutable_owner() {
  
  return owner_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Source::release_owner() {
  // @@protoc_insertion_point(field_release:zorro.protobuf.Source.owner)
  return owner_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Source::set_allocated_owner(std::string* owner) {
  if (owner != nullptr) {
    
  } else {
    
  }
  owner_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), owner,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (owner_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    owner_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:zorro.protobuf.Source.owner)
}

// map<string, string> parameters = 3;
inline int Source::_internal_parameters_size() const {
  return parameters_.size();
}
inline int Source::parameters_size() const {
  return _internal_parameters_size();
}
inline void Source::clear_parameters() {
  parameters_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
Source::_internal_parameters() const {
  return parameters_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
Source::parameters() const {
  // @@protoc_insertion_point(field_map:zorro.protobuf.Source.parameters)
  return _internal_parameters();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
Source::_internal_mutable_parameters() {
  return parameters_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
Source::mutable_parameters() {
  // @@protoc_insertion_point(field_mutable_map:zorro.protobuf.Source.parameters)
  return _internal_mutable_parameters();
}

// -------------------------------------------------------------------

// SourceGroup

// string semantics = 1;
inline void SourceGroup::clear_semantics() {
  semantics_.ClearToEmpty();
}
inline const std::string& SourceGroup::semantics() const {
  // @@protoc_insertion_point(field_get:zorro.protobuf.SourceGroup.semantics)
  return _internal_semantics();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SourceGroup::set_semantics(ArgT0&& arg0, ArgT... args) {
 
 semantics_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:zorro.protobuf.SourceGroup.semantics)
}
inline std::string* SourceGroup::mutable_semantics() {
  std::string* _s = _internal_mutable_semantics();
  // @@protoc_insertion_point(field_mutable:zorro.protobuf.SourceGroup.semantics)
  return _s;
}
inline const std::string& SourceGroup::_internal_semantics() const {
  return semantics_.Get();
}
inline void SourceGroup::_internal_set_semantics(const std::string& value) {
  
  semantics_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* SourceGroup::_internal_mutable_semantics() {
  
  return semantics_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* SourceGroup::release_semantics() {
  // @@protoc_insertion_point(field_release:zorro.protobuf.SourceGroup.semantics)
  return semantics_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void SourceGroup::set_allocated_semantics(std::string* semantics) {
  if (semantics != nullptr) {
    
  } else {
    
  }
  semantics_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), semantics,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (semantics_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    semantics_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:zorro.protobuf.SourceGroup.semantics)
}

// repeated string ssrc = 2;
inline int SourceGroup::_internal_ssrc_size() const {
  return ssrc_.size();
}
inline int SourceGroup::ssrc_size() const {
  return _internal_ssrc_size();
}
inline void SourceGroup::clear_ssrc() {
  ssrc_.Clear();
}
inline std::string* SourceGroup::add_ssrc() {
  std::string* _s = _internal_add_ssrc();
  // @@protoc_insertion_point(field_add_mutable:zorro.protobuf.SourceGroup.ssrc)
  return _s;
}
inline const std::string& SourceGroup::_internal_ssrc(int index) const {
  return ssrc_.Get(index);
}
inline const std::string& SourceGroup::ssrc(int index) const {
  // @@protoc_insertion_point(field_get:zorro.protobuf.SourceGroup.ssrc)
  return _internal_ssrc(index);
}
inline std::string* SourceGroup::mutable_ssrc(int index) {
  // @@protoc_insertion_point(field_mutable:zorro.protobuf.SourceGroup.ssrc)
  return ssrc_.Mutable(index);
}
inline void SourceGroup::set_ssrc(int index, const std::string& value) {
  ssrc_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:zorro.protobuf.SourceGroup.ssrc)
}
inline void SourceGroup::set_ssrc(int index, std::string&& value) {
  ssrc_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:zorro.protobuf.SourceGroup.ssrc)
}
inline void SourceGroup::set_ssrc(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  ssrc_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:zorro.protobuf.SourceGroup.ssrc)
}
inline void SourceGroup::set_ssrc(int index, const char* value, size_t size) {
  ssrc_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:zorro.protobuf.SourceGroup.ssrc)
}
inline std::string* SourceGroup::_internal_add_ssrc() {
  return ssrc_.Add();
}
inline void SourceGroup::add_ssrc(const std::string& value) {
  ssrc_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:zorro.protobuf.SourceGroup.ssrc)
}
inline void SourceGroup::add_ssrc(std::string&& value) {
  ssrc_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:zorro.protobuf.SourceGroup.ssrc)
}
inline void SourceGroup::add_ssrc(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  ssrc_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:zorro.protobuf.SourceGroup.ssrc)
}
inline void SourceGroup::add_ssrc(const char* value, size_t size) {
  ssrc_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:zorro.protobuf.SourceGroup.ssrc)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
SourceGroup::ssrc() const {
  // @@protoc_insertion_point(field_list:zorro.protobuf.SourceGroup.ssrc)
  return ssrc_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
SourceGroup::mutable_ssrc() {
  // @@protoc_insertion_point(field_mutable_list:zorro.protobuf.SourceGroup.ssrc)
  return &ssrc_;
}

// -------------------------------------------------------------------

// Description

// string media = 1;
inline void Description::clear_media() {
  media_.ClearToEmpty();
}
inline const std::string& Description::media() const {
  // @@protoc_insertion_point(field_get:zorro.protobuf.Description.media)
  return _internal_media();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Description::set_media(ArgT0&& arg0, ArgT... args) {
 
 media_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:zorro.protobuf.Description.media)
}
inline std::string* Description::mutable_media() {
  std::string* _s = _internal_mutable_media();
  // @@protoc_insertion_point(field_mutable:zorro.protobuf.Description.media)
  return _s;
}
inline const std::string& Description::_internal_media() const {
  return media_.Get();
}
inline void Description::_internal_set_media(const std::string& value) {
  
  media_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Description::_internal_mutable_media() {
  
  return media_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Description::release_media() {
  // @@protoc_insertion_point(field_release:zorro.protobuf.Description.media)
  return media_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Description::set_allocated_media(std::string* media) {
  if (media != nullptr) {
    
  } else {
    
  }
  media_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), media,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (media_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    media_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:zorro.protobuf.Description.media)
}

// int32 maxptime = 2;
inline void Description::clear_maxptime() {
  maxptime_ = 0;
}
inline int32_t Description::_internal_maxptime() const {
  return maxptime_;
}
inline int32_t Description::maxptime() const {
  // @@protoc_insertion_point(field_get:zorro.protobuf.Description.maxptime)
  return _internal_maxptime();
}
inline void Description::_internal_set_maxptime(int32_t value) {
  
  maxptime_ = value;
}
inline void Description::set_maxptime(int32_t value) {
  _internal_set_maxptime(value);
  // @@protoc_insertion_point(field_set:zorro.protobuf.Description.maxptime)
}

// repeated .zorro.protobuf.PayloadType payloadType = 3;
inline int Description::_internal_payloadtype_size() const {
  return payloadtype_.size();
}
inline int Description::payloadtype_size() const {
  return _internal_payloadtype_size();
}
inline void Description::clear_payloadtype() {
  payloadtype_.Clear();
}
inline ::zorro::protobuf::PayloadType* Description::mutable_payloadtype(int index) {
  // @@protoc_insertion_point(field_mutable:zorro.protobuf.Description.payloadType)
  return payloadtype_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zorro::protobuf::PayloadType >*
Description::mutable_payloadtype() {
  // @@protoc_insertion_point(field_mutable_list:zorro.protobuf.Description.payloadType)
  return &payloadtype_;
}
inline const ::zorro::protobuf::PayloadType& Description::_internal_payloadtype(int index) const {
  return payloadtype_.Get(index);
}
inline const ::zorro::protobuf::PayloadType& Description::payloadtype(int index) const {
  // @@protoc_insertion_point(field_get:zorro.protobuf.Description.payloadType)
  return _internal_payloadtype(index);
}
inline ::zorro::protobuf::PayloadType* Description::_internal_add_payloadtype() {
  return payloadtype_.Add();
}
inline ::zorro::protobuf::PayloadType* Description::add_payloadtype() {
  ::zorro::protobuf::PayloadType* _add = _internal_add_payloadtype();
  // @@protoc_insertion_point(field_add:zorro.protobuf.Description.payloadType)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zorro::protobuf::PayloadType >&
Description::payloadtype() const {
  // @@protoc_insertion_point(field_list:zorro.protobuf.Description.payloadType)
  return payloadtype_;
}

// repeated .zorro.protobuf.RtpHdrExt rtpHdrExt = 4;
inline int Description::_internal_rtphdrext_size() const {
  return rtphdrext_.size();
}
inline int Description::rtphdrext_size() const {
  return _internal_rtphdrext_size();
}
inline void Description::clear_rtphdrext() {
  rtphdrext_.Clear();
}
inline ::zorro::protobuf::RtpHdrExt* Description::mutable_rtphdrext(int index) {
  // @@protoc_insertion_point(field_mutable:zorro.protobuf.Description.rtpHdrExt)
  return rtphdrext_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zorro::protobuf::RtpHdrExt >*
Description::mutable_rtphdrext() {
  // @@protoc_insertion_point(field_mutable_list:zorro.protobuf.Description.rtpHdrExt)
  return &rtphdrext_;
}
inline const ::zorro::protobuf::RtpHdrExt& Description::_internal_rtphdrext(int index) const {
  return rtphdrext_.Get(index);
}
inline const ::zorro::protobuf::RtpHdrExt& Description::rtphdrext(int index) const {
  // @@protoc_insertion_point(field_get:zorro.protobuf.Description.rtpHdrExt)
  return _internal_rtphdrext(index);
}
inline ::zorro::protobuf::RtpHdrExt* Description::_internal_add_rtphdrext() {
  return rtphdrext_.Add();
}
inline ::zorro::protobuf::RtpHdrExt* Description::add_rtphdrext() {
  ::zorro::protobuf::RtpHdrExt* _add = _internal_add_rtphdrext();
  // @@protoc_insertion_point(field_add:zorro.protobuf.Description.rtpHdrExt)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zorro::protobuf::RtpHdrExt >&
Description::rtphdrext() const {
  // @@protoc_insertion_point(field_list:zorro.protobuf.Description.rtpHdrExt)
  return rtphdrext_;
}

// bool rtcpMux = 5;
inline void Description::clear_rtcpmux() {
  rtcpmux_ = false;
}
inline bool Description::_internal_rtcpmux() const {
  return rtcpmux_;
}
inline bool Description::rtcpmux() const {
  // @@protoc_insertion_point(field_get:zorro.protobuf.Description.rtcpMux)
  return _internal_rtcpmux();
}
inline void Description::_internal_set_rtcpmux(bool value) {
  
  rtcpmux_ = value;
}
inline void Description::set_rtcpmux(bool value) {
  _internal_set_rtcpmux(value);
  // @@protoc_insertion_point(field_set:zorro.protobuf.Description.rtcpMux)
}

// repeated .zorro.protobuf.Source source = 6;
inline int Description::_internal_source_size() const {
  return source_.size();
}
inline int Description::source_size() const {
  return _internal_source_size();
}
inline void Description::clear_source() {
  source_.Clear();
}
inline ::zorro::protobuf::Source* Description::mutable_source(int index) {
  // @@protoc_insertion_point(field_mutable:zorro.protobuf.Description.source)
  return source_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zorro::protobuf::Source >*
Description::mutable_source() {
  // @@protoc_insertion_point(field_mutable_list:zorro.protobuf.Description.source)
  return &source_;
}
inline const ::zorro::protobuf::Source& Description::_internal_source(int index) const {
  return source_.Get(index);
}
inline const ::zorro::protobuf::Source& Description::source(int index) const {
  // @@protoc_insertion_point(field_get:zorro.protobuf.Description.source)
  return _internal_source(index);
}
inline ::zorro::protobuf::Source* Description::_internal_add_source() {
  return source_.Add();
}
inline ::zorro::protobuf::Source* Description::add_source() {
  ::zorro::protobuf::Source* _add = _internal_add_source();
  // @@protoc_insertion_point(field_add:zorro.protobuf.Description.source)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zorro::protobuf::Source >&
Description::source() const {
  // @@protoc_insertion_point(field_list:zorro.protobuf.Description.source)
  return source_;
}

// repeated .zorro.protobuf.SourceGroup sourceGroup = 7;
inline int Description::_internal_sourcegroup_size() const {
  return sourcegroup_.size();
}
inline int Description::sourcegroup_size() const {
  return _internal_sourcegroup_size();
}
inline void Description::clear_sourcegroup() {
  sourcegroup_.Clear();
}
inline ::zorro::protobuf::SourceGroup* Description::mutable_sourcegroup(int index) {
  // @@protoc_insertion_point(field_mutable:zorro.protobuf.Description.sourceGroup)
  return sourcegroup_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zorro::protobuf::SourceGroup >*
Description::mutable_sourcegroup() {
  // @@protoc_insertion_point(field_mutable_list:zorro.protobuf.Description.sourceGroup)
  return &sourcegroup_;
}
inline const ::zorro::protobuf::SourceGroup& Description::_internal_sourcegroup(int index) const {
  return sourcegroup_.Get(index);
}
inline const ::zorro::protobuf::SourceGroup& Description::sourcegroup(int index) const {
  // @@protoc_insertion_point(field_get:zorro.protobuf.Description.sourceGroup)
  return _internal_sourcegroup(index);
}
inline ::zorro::protobuf::SourceGroup* Description::_internal_add_sourcegroup() {
  return sourcegroup_.Add();
}
inline ::zorro::protobuf::SourceGroup* Description::add_sourcegroup() {
  ::zorro::protobuf::SourceGroup* _add = _internal_add_sourcegroup();
  // @@protoc_insertion_point(field_add:zorro.protobuf.Description.sourceGroup)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zorro::protobuf::SourceGroup >&
Description::sourcegroup() const {
  // @@protoc_insertion_point(field_list:zorro.protobuf.Description.sourceGroup)
  return sourcegroup_;
}

// -------------------------------------------------------------------

// Fingerprint

// string hashType = 1;
inline void Fingerprint::clear_hashtype() {
  hashtype_.ClearToEmpty();
}
inline const std::string& Fingerprint::hashtype() const {
  // @@protoc_insertion_point(field_get:zorro.protobuf.Fingerprint.hashType)
  return _internal_hashtype();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Fingerprint::set_hashtype(ArgT0&& arg0, ArgT... args) {
 
 hashtype_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:zorro.protobuf.Fingerprint.hashType)
}
inline std::string* Fingerprint::mutable_hashtype() {
  std::string* _s = _internal_mutable_hashtype();
  // @@protoc_insertion_point(field_mutable:zorro.protobuf.Fingerprint.hashType)
  return _s;
}
inline const std::string& Fingerprint::_internal_hashtype() const {
  return hashtype_.Get();
}
inline void Fingerprint::_internal_set_hashtype(const std::string& value) {
  
  hashtype_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Fingerprint::_internal_mutable_hashtype() {
  
  return hashtype_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Fingerprint::release_hashtype() {
  // @@protoc_insertion_point(field_release:zorro.protobuf.Fingerprint.hashType)
  return hashtype_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Fingerprint::set_allocated_hashtype(std::string* hashtype) {
  if (hashtype != nullptr) {
    
  } else {
    
  }
  hashtype_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), hashtype,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (hashtype_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    hashtype_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:zorro.protobuf.Fingerprint.hashType)
}

// bool required = 2;
inline void Fingerprint::clear_required() {
  required_ = false;
}
inline bool Fingerprint::_internal_required() const {
  return required_;
}
inline bool Fingerprint::required() const {
  // @@protoc_insertion_point(field_get:zorro.protobuf.Fingerprint.required)
  return _internal_required();
}
inline void Fingerprint::_internal_set_required(bool value) {
  
  required_ = value;
}
inline void Fingerprint::set_required(bool value) {
  _internal_set_required(value);
  // @@protoc_insertion_point(field_set:zorro.protobuf.Fingerprint.required)
}

// string setup = 3;
inline void Fingerprint::clear_setup() {
  setup_.ClearToEmpty();
}
inline const std::string& Fingerprint::setup() const {
  // @@protoc_insertion_point(field_get:zorro.protobuf.Fingerprint.setup)
  return _internal_setup();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Fingerprint::set_setup(ArgT0&& arg0, ArgT... args) {
 
 setup_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:zorro.protobuf.Fingerprint.setup)
}
inline std::string* Fingerprint::mutable_setup() {
  std::string* _s = _internal_mutable_setup();
  // @@protoc_insertion_point(field_mutable:zorro.protobuf.Fingerprint.setup)
  return _s;
}
inline const std::string& Fingerprint::_internal_setup() const {
  return setup_.Get();
}
inline void Fingerprint::_internal_set_setup(const std::string& value) {
  
  setup_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Fingerprint::_internal_mutable_setup() {
  
  return setup_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Fingerprint::release_setup() {
  // @@protoc_insertion_point(field_release:zorro.protobuf.Fingerprint.setup)
  return setup_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Fingerprint::set_allocated_setup(std::string* setup) {
  if (setup != nullptr) {
    
  } else {
    
  }
  setup_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), setup,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (setup_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    setup_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:zorro.protobuf.Fingerprint.setup)
}

// string value = 4;
inline void Fingerprint::clear_value() {
  value_.ClearToEmpty();
}
inline const std::string& Fingerprint::value() const {
  // @@protoc_insertion_point(field_get:zorro.protobuf.Fingerprint.value)
  return _internal_value();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Fingerprint::set_value(ArgT0&& arg0, ArgT... args) {
 
 value_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:zorro.protobuf.Fingerprint.value)
}
inline std::string* Fingerprint::mutable_value() {
  std::string* _s = _internal_mutable_value();
  // @@protoc_insertion_point(field_mutable:zorro.protobuf.Fingerprint.value)
  return _s;
}
inline const std::string& Fingerprint::_internal_value() const {
  return value_.Get();
}
inline void Fingerprint::_internal_set_value(const std::string& value) {
  
  value_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Fingerprint::_internal_mutable_value() {
  
  return value_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Fingerprint::release_value() {
  // @@protoc_insertion_point(field_release:zorro.protobuf.Fingerprint.value)
  return value_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Fingerprint::set_allocated_value(std::string* value) {
  if (value != nullptr) {
    
  } else {
    
  }
  value_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (value_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:zorro.protobuf.Fingerprint.value)
}

// -------------------------------------------------------------------

// Crypto

// string tag = 1;
inline void Crypto::clear_tag() {
  tag_.ClearToEmpty();
}
inline const std::string& Crypto::tag() const {
  // @@protoc_insertion_point(field_get:zorro.protobuf.Crypto.tag)
  return _internal_tag();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Crypto::set_tag(ArgT0&& arg0, ArgT... args) {
 
 tag_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:zorro.protobuf.Crypto.tag)
}
inline std::string* Crypto::mutable_tag() {
  std::string* _s = _internal_mutable_tag();
  // @@protoc_insertion_point(field_mutable:zorro.protobuf.Crypto.tag)
  return _s;
}
inline const std::string& Crypto::_internal_tag() const {
  return tag_.Get();
}
inline void Crypto::_internal_set_tag(const std::string& value) {
  
  tag_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Crypto::_internal_mutable_tag() {
  
  return tag_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Crypto::release_tag() {
  // @@protoc_insertion_point(field_release:zorro.protobuf.Crypto.tag)
  return tag_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Crypto::set_allocated_tag(std::string* tag) {
  if (tag != nullptr) {
    
  } else {
    
  }
  tag_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), tag,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (tag_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    tag_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:zorro.protobuf.Crypto.tag)
}

// string suite = 2;
inline void Crypto::clear_suite() {
  suite_.ClearToEmpty();
}
inline const std::string& Crypto::suite() const {
  // @@protoc_insertion_point(field_get:zorro.protobuf.Crypto.suite)
  return _internal_suite();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Crypto::set_suite(ArgT0&& arg0, ArgT... args) {
 
 suite_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:zorro.protobuf.Crypto.suite)
}
inline std::string* Crypto::mutable_suite() {
  std::string* _s = _internal_mutable_suite();
  // @@protoc_insertion_point(field_mutable:zorro.protobuf.Crypto.suite)
  return _s;
}
inline const std::string& Crypto::_internal_suite() const {
  return suite_.Get();
}
inline void Crypto::_internal_set_suite(const std::string& value) {
  
  suite_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Crypto::_internal_mutable_suite() {
  
  return suite_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Crypto::release_suite() {
  // @@protoc_insertion_point(field_release:zorro.protobuf.Crypto.suite)
  return suite_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Crypto::set_allocated_suite(std::string* suite) {
  if (suite != nullptr) {
    
  } else {
    
  }
  suite_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), suite,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (suite_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    suite_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:zorro.protobuf.Crypto.suite)
}

// string keyParams = 3;
inline void Crypto::clear_keyparams() {
  keyparams_.ClearToEmpty();
}
inline const std::string& Crypto::keyparams() const {
  // @@protoc_insertion_point(field_get:zorro.protobuf.Crypto.keyParams)
  return _internal_keyparams();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Crypto::set_keyparams(ArgT0&& arg0, ArgT... args) {
 
 keyparams_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:zorro.protobuf.Crypto.keyParams)
}
inline std::string* Crypto::mutable_keyparams() {
  std::string* _s = _internal_mutable_keyparams();
  // @@protoc_insertion_point(field_mutable:zorro.protobuf.Crypto.keyParams)
  return _s;
}
inline const std::string& Crypto::_internal_keyparams() const {
  return keyparams_.Get();
}
inline void Crypto::_internal_set_keyparams(const std::string& value) {
  
  keyparams_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Crypto::_internal_mutable_keyparams() {
  
  return keyparams_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Crypto::release_keyparams() {
  // @@protoc_insertion_point(field_release:zorro.protobuf.Crypto.keyParams)
  return keyparams_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Crypto::set_allocated_keyparams(std::string* keyparams) {
  if (keyparams != nullptr) {
    
  } else {
    
  }
  keyparams_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), keyparams,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (keyparams_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    keyparams_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:zorro.protobuf.Crypto.keyParams)
}

// string sessParams = 4;
inline void Crypto::clear_sessparams() {
  sessparams_.ClearToEmpty();
}
inline const std::string& Crypto::sessparams() const {
  // @@protoc_insertion_point(field_get:zorro.protobuf.Crypto.sessParams)
  return _internal_sessparams();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Crypto::set_sessparams(ArgT0&& arg0, ArgT... args) {
 
 sessparams_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:zorro.protobuf.Crypto.sessParams)
}
inline std::string* Crypto::mutable_sessparams() {
  std::string* _s = _internal_mutable_sessparams();
  // @@protoc_insertion_point(field_mutable:zorro.protobuf.Crypto.sessParams)
  return _s;
}
inline const std::string& Crypto::_internal_sessparams() const {
  return sessparams_.Get();
}
inline void Crypto::_internal_set_sessparams(const std::string& value) {
  
  sessparams_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Crypto::_internal_mutable_sessparams() {
  
  return sessparams_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Crypto::release_sessparams() {
  // @@protoc_insertion_point(field_release:zorro.protobuf.Crypto.sessParams)
  return sessparams_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Crypto::set_allocated_sessparams(std::string* sessparams) {
  if (sessparams != nullptr) {
    
  } else {
    
  }
  sessparams_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), sessparams,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (sessparams_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    sessparams_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:zorro.protobuf.Crypto.sessParams)
}

// -------------------------------------------------------------------

// Candidate

// int32 component = 1;
inline void Candidate::clear_component() {
  component_ = 0;
}
inline int32_t Candidate::_internal_component() const {
  return component_;
}
inline int32_t Candidate::component() const {
  // @@protoc_insertion_point(field_get:zorro.protobuf.Candidate.component)
  return _internal_component();
}
inline void Candidate::_internal_set_component(int32_t value) {
  
  component_ = value;
}
inline void Candidate::set_component(int32_t value) {
  _internal_set_component(value);
  // @@protoc_insertion_point(field_set:zorro.protobuf.Candidate.component)
}

// string foundation = 2;
inline void Candidate::clear_foundation() {
  foundation_.ClearToEmpty();
}
inline const std::string& Candidate::foundation() const {
  // @@protoc_insertion_point(field_get:zorro.protobuf.Candidate.foundation)
  return _internal_foundation();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Candidate::set_foundation(ArgT0&& arg0, ArgT... args) {
 
 foundation_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:zorro.protobuf.Candidate.foundation)
}
inline std::string* Candidate::mutable_foundation() {
  std::string* _s = _internal_mutable_foundation();
  // @@protoc_insertion_point(field_mutable:zorro.protobuf.Candidate.foundation)
  return _s;
}
inline const std::string& Candidate::_internal_foundation() const {
  return foundation_.Get();
}
inline void Candidate::_internal_set_foundation(const std::string& value) {
  
  foundation_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Candidate::_internal_mutable_foundation() {
  
  return foundation_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Candidate::release_foundation() {
  // @@protoc_insertion_point(field_release:zorro.protobuf.Candidate.foundation)
  return foundation_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Candidate::set_allocated_foundation(std::string* foundation) {
  if (foundation != nullptr) {
    
  } else {
    
  }
  foundation_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), foundation,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (foundation_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    foundation_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:zorro.protobuf.Candidate.foundation)
}

// int32 generation = 3;
inline void Candidate::clear_generation() {
  generation_ = 0;
}
inline int32_t Candidate::_internal_generation() const {
  return generation_;
}
inline int32_t Candidate::generation() const {
  // @@protoc_insertion_point(field_get:zorro.protobuf.Candidate.generation)
  return _internal_generation();
}
inline void Candidate::_internal_set_generation(int32_t value) {
  
  generation_ = value;
}
inline void Candidate::set_generation(int32_t value) {
  _internal_set_generation(value);
  // @@protoc_insertion_point(field_set:zorro.protobuf.Candidate.generation)
}

// string id = 4;
inline void Candidate::clear_id() {
  id_.ClearToEmpty();
}
inline const std::string& Candidate::id() const {
  // @@protoc_insertion_point(field_get:zorro.protobuf.Candidate.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Candidate::set_id(ArgT0&& arg0, ArgT... args) {
 
 id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:zorro.protobuf.Candidate.id)
}
inline std::string* Candidate::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:zorro.protobuf.Candidate.id)
  return _s;
}
inline const std::string& Candidate::_internal_id() const {
  return id_.Get();
}
inline void Candidate::_internal_set_id(const std::string& value) {
  
  id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Candidate::_internal_mutable_id() {
  
  return id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Candidate::release_id() {
  // @@protoc_insertion_point(field_release:zorro.protobuf.Candidate.id)
  return id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Candidate::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), id,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:zorro.protobuf.Candidate.id)
}

// int32 network = 5;
inline void Candidate::clear_network() {
  network_ = 0;
}
inline int32_t Candidate::_internal_network() const {
  return network_;
}
inline int32_t Candidate::network() const {
  // @@protoc_insertion_point(field_get:zorro.protobuf.Candidate.network)
  return _internal_network();
}
inline void Candidate::_internal_set_network(int32_t value) {
  
  network_ = value;
}
inline void Candidate::set_network(int32_t value) {
  _internal_set_network(value);
  // @@protoc_insertion_point(field_set:zorro.protobuf.Candidate.network)
}

// int64 priority = 6;
inline void Candidate::clear_priority() {
  priority_ = int64_t{0};
}
inline int64_t Candidate::_internal_priority() const {
  return priority_;
}
inline int64_t Candidate::priority() const {
  // @@protoc_insertion_point(field_get:zorro.protobuf.Candidate.priority)
  return _internal_priority();
}
inline void Candidate::_internal_set_priority(int64_t value) {
  
  priority_ = value;
}
inline void Candidate::set_priority(int64_t value) {
  _internal_set_priority(value);
  // @@protoc_insertion_point(field_set:zorro.protobuf.Candidate.priority)
}

// string protocol = 7;
inline void Candidate::clear_protocol() {
  protocol_.ClearToEmpty();
}
inline const std::string& Candidate::protocol() const {
  // @@protoc_insertion_point(field_get:zorro.protobuf.Candidate.protocol)
  return _internal_protocol();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Candidate::set_protocol(ArgT0&& arg0, ArgT... args) {
 
 protocol_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:zorro.protobuf.Candidate.protocol)
}
inline std::string* Candidate::mutable_protocol() {
  std::string* _s = _internal_mutable_protocol();
  // @@protoc_insertion_point(field_mutable:zorro.protobuf.Candidate.protocol)
  return _s;
}
inline const std::string& Candidate::_internal_protocol() const {
  return protocol_.Get();
}
inline void Candidate::_internal_set_protocol(const std::string& value) {
  
  protocol_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Candidate::_internal_mutable_protocol() {
  
  return protocol_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Candidate::release_protocol() {
  // @@protoc_insertion_point(field_release:zorro.protobuf.Candidate.protocol)
  return protocol_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Candidate::set_allocated_protocol(std::string* protocol) {
  if (protocol != nullptr) {
    
  } else {
    
  }
  protocol_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), protocol,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (protocol_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    protocol_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:zorro.protobuf.Candidate.protocol)
}

// string tcptype = 8;
inline void Candidate::clear_tcptype() {
  tcptype_.ClearToEmpty();
}
inline const std::string& Candidate::tcptype() const {
  // @@protoc_insertion_point(field_get:zorro.protobuf.Candidate.tcptype)
  return _internal_tcptype();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Candidate::set_tcptype(ArgT0&& arg0, ArgT... args) {
 
 tcptype_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:zorro.protobuf.Candidate.tcptype)
}
inline std::string* Candidate::mutable_tcptype() {
  std::string* _s = _internal_mutable_tcptype();
  // @@protoc_insertion_point(field_mutable:zorro.protobuf.Candidate.tcptype)
  return _s;
}
inline const std::string& Candidate::_internal_tcptype() const {
  return tcptype_.Get();
}
inline void Candidate::_internal_set_tcptype(const std::string& value) {
  
  tcptype_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Candidate::_internal_mutable_tcptype() {
  
  return tcptype_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Candidate::release_tcptype() {
  // @@protoc_insertion_point(field_release:zorro.protobuf.Candidate.tcptype)
  return tcptype_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Candidate::set_allocated_tcptype(std::string* tcptype) {
  if (tcptype != nullptr) {
    
  } else {
    
  }
  tcptype_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), tcptype,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (tcptype_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    tcptype_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:zorro.protobuf.Candidate.tcptype)
}

// string type = 9;
inline void Candidate::clear_type() {
  type_.ClearToEmpty();
}
inline const std::string& Candidate::type() const {
  // @@protoc_insertion_point(field_get:zorro.protobuf.Candidate.type)
  return _internal_type();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Candidate::set_type(ArgT0&& arg0, ArgT... args) {
 
 type_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:zorro.protobuf.Candidate.type)
}
inline std::string* Candidate::mutable_type() {
  std::string* _s = _internal_mutable_type();
  // @@protoc_insertion_point(field_mutable:zorro.protobuf.Candidate.type)
  return _s;
}
inline const std::string& Candidate::_internal_type() const {
  return type_.Get();
}
inline void Candidate::_internal_set_type(const std::string& value) {
  
  type_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Candidate::_internal_mutable_type() {
  
  return type_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Candidate::release_type() {
  // @@protoc_insertion_point(field_release:zorro.protobuf.Candidate.type)
  return type_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Candidate::set_allocated_type(std::string* type) {
  if (type != nullptr) {
    
  } else {
    
  }
  type_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), type,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (type_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    type_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:zorro.protobuf.Candidate.type)
}

// string ip = 10;
inline void Candidate::clear_ip() {
  ip_.ClearToEmpty();
}
inline const std::string& Candidate::ip() const {
  // @@protoc_insertion_point(field_get:zorro.protobuf.Candidate.ip)
  return _internal_ip();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Candidate::set_ip(ArgT0&& arg0, ArgT... args) {
 
 ip_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:zorro.protobuf.Candidate.ip)
}
inline std::string* Candidate::mutable_ip() {
  std::string* _s = _internal_mutable_ip();
  // @@protoc_insertion_point(field_mutable:zorro.protobuf.Candidate.ip)
  return _s;
}
inline const std::string& Candidate::_internal_ip() const {
  return ip_.Get();
}
inline void Candidate::_internal_set_ip(const std::string& value) {
  
  ip_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Candidate::_internal_mutable_ip() {
  
  return ip_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Candidate::release_ip() {
  // @@protoc_insertion_point(field_release:zorro.protobuf.Candidate.ip)
  return ip_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Candidate::set_allocated_ip(std::string* ip) {
  if (ip != nullptr) {
    
  } else {
    
  }
  ip_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ip,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (ip_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    ip_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:zorro.protobuf.Candidate.ip)
}

// string domain = 11;
inline void Candidate::clear_domain() {
  domain_.ClearToEmpty();
}
inline const std::string& Candidate::domain() const {
  // @@protoc_insertion_point(field_get:zorro.protobuf.Candidate.domain)
  return _internal_domain();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Candidate::set_domain(ArgT0&& arg0, ArgT... args) {
 
 domain_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:zorro.protobuf.Candidate.domain)
}
inline std::string* Candidate::mutable_domain() {
  std::string* _s = _internal_mutable_domain();
  // @@protoc_insertion_point(field_mutable:zorro.protobuf.Candidate.domain)
  return _s;
}
inline const std::string& Candidate::_internal_domain() const {
  return domain_.Get();
}
inline void Candidate::_internal_set_domain(const std::string& value) {
  
  domain_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Candidate::_internal_mutable_domain() {
  
  return domain_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Candidate::release_domain() {
  // @@protoc_insertion_point(field_release:zorro.protobuf.Candidate.domain)
  return domain_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Candidate::set_allocated_domain(std::string* domain) {
  if (domain != nullptr) {
    
  } else {
    
  }
  domain_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), domain,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (domain_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    domain_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:zorro.protobuf.Candidate.domain)
}

// int32 port = 12;
inline void Candidate::clear_port() {
  port_ = 0;
}
inline int32_t Candidate::_internal_port() const {
  return port_;
}
inline int32_t Candidate::port() const {
  // @@protoc_insertion_point(field_get:zorro.protobuf.Candidate.port)
  return _internal_port();
}
inline void Candidate::_internal_set_port(int32_t value) {
  
  port_ = value;
}
inline void Candidate::set_port(int32_t value) {
  _internal_set_port(value);
  // @@protoc_insertion_point(field_set:zorro.protobuf.Candidate.port)
}

// string realAddr = 13;
inline void Candidate::clear_realaddr() {
  realaddr_.ClearToEmpty();
}
inline const std::string& Candidate::realaddr() const {
  // @@protoc_insertion_point(field_get:zorro.protobuf.Candidate.realAddr)
  return _internal_realaddr();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Candidate::set_realaddr(ArgT0&& arg0, ArgT... args) {
 
 realaddr_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:zorro.protobuf.Candidate.realAddr)
}
inline std::string* Candidate::mutable_realaddr() {
  std::string* _s = _internal_mutable_realaddr();
  // @@protoc_insertion_point(field_mutable:zorro.protobuf.Candidate.realAddr)
  return _s;
}
inline const std::string& Candidate::_internal_realaddr() const {
  return realaddr_.Get();
}
inline void Candidate::_internal_set_realaddr(const std::string& value) {
  
  realaddr_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Candidate::_internal_mutable_realaddr() {
  
  return realaddr_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Candidate::release_realaddr() {
  // @@protoc_insertion_point(field_release:zorro.protobuf.Candidate.realAddr)
  return realaddr_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Candidate::set_allocated_realaddr(std::string* realaddr) {
  if (realaddr != nullptr) {
    
  } else {
    
  }
  realaddr_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), realaddr,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (realaddr_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    realaddr_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:zorro.protobuf.Candidate.realAddr)
}

// int32 realPort = 14;
inline void Candidate::clear_realport() {
  realport_ = 0;
}
inline int32_t Candidate::_internal_realport() const {
  return realport_;
}
inline int32_t Candidate::realport() const {
  // @@protoc_insertion_point(field_get:zorro.protobuf.Candidate.realPort)
  return _internal_realport();
}
inline void Candidate::_internal_set_realport(int32_t value) {
  
  realport_ = value;
}
inline void Candidate::set_realport(int32_t value) {
  _internal_set_realport(value);
  // @@protoc_insertion_point(field_set:zorro.protobuf.Candidate.realPort)
}

// -------------------------------------------------------------------

// Transport

// string ufrag = 1;
inline void Transport::clear_ufrag() {
  ufrag_.ClearToEmpty();
}
inline const std::string& Transport::ufrag() const {
  // @@protoc_insertion_point(field_get:zorro.protobuf.Transport.ufrag)
  return _internal_ufrag();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Transport::set_ufrag(ArgT0&& arg0, ArgT... args) {
 
 ufrag_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:zorro.protobuf.Transport.ufrag)
}
inline std::string* Transport::mutable_ufrag() {
  std::string* _s = _internal_mutable_ufrag();
  // @@protoc_insertion_point(field_mutable:zorro.protobuf.Transport.ufrag)
  return _s;
}
inline const std::string& Transport::_internal_ufrag() const {
  return ufrag_.Get();
}
inline void Transport::_internal_set_ufrag(const std::string& value) {
  
  ufrag_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Transport::_internal_mutable_ufrag() {
  
  return ufrag_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Transport::release_ufrag() {
  // @@protoc_insertion_point(field_release:zorro.protobuf.Transport.ufrag)
  return ufrag_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Transport::set_allocated_ufrag(std::string* ufrag) {
  if (ufrag != nullptr) {
    
  } else {
    
  }
  ufrag_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ufrag,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (ufrag_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    ufrag_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:zorro.protobuf.Transport.ufrag)
}

// string pwd = 2;
inline void Transport::clear_pwd() {
  pwd_.ClearToEmpty();
}
inline const std::string& Transport::pwd() const {
  // @@protoc_insertion_point(field_get:zorro.protobuf.Transport.pwd)
  return _internal_pwd();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Transport::set_pwd(ArgT0&& arg0, ArgT... args) {
 
 pwd_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:zorro.protobuf.Transport.pwd)
}
inline std::string* Transport::mutable_pwd() {
  std::string* _s = _internal_mutable_pwd();
  // @@protoc_insertion_point(field_mutable:zorro.protobuf.Transport.pwd)
  return _s;
}
inline const std::string& Transport::_internal_pwd() const {
  return pwd_.Get();
}
inline void Transport::_internal_set_pwd(const std::string& value) {
  
  pwd_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Transport::_internal_mutable_pwd() {
  
  return pwd_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Transport::release_pwd() {
  // @@protoc_insertion_point(field_release:zorro.protobuf.Transport.pwd)
  return pwd_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Transport::set_allocated_pwd(std::string* pwd) {
  if (pwd != nullptr) {
    
  } else {
    
  }
  pwd_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), pwd,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (pwd_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    pwd_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:zorro.protobuf.Transport.pwd)
}

// bool rtcpMux = 3;
inline void Transport::clear_rtcpmux() {
  rtcpmux_ = false;
}
inline bool Transport::_internal_rtcpmux() const {
  return rtcpmux_;
}
inline bool Transport::rtcpmux() const {
  // @@protoc_insertion_point(field_get:zorro.protobuf.Transport.rtcpMux)
  return _internal_rtcpmux();
}
inline void Transport::_internal_set_rtcpmux(bool value) {
  
  rtcpmux_ = value;
}
inline void Transport::set_rtcpmux(bool value) {
  _internal_set_rtcpmux(value);
  // @@protoc_insertion_point(field_set:zorro.protobuf.Transport.rtcpMux)
}

// .zorro.protobuf.Fingerprint fingerprint = 4;
inline bool Transport::_internal_has_fingerprint() const {
  return this != internal_default_instance() && fingerprint_ != nullptr;
}
inline bool Transport::has_fingerprint() const {
  return _internal_has_fingerprint();
}
inline void Transport::clear_fingerprint() {
  if (GetArenaForAllocation() == nullptr && fingerprint_ != nullptr) {
    delete fingerprint_;
  }
  fingerprint_ = nullptr;
}
inline const ::zorro::protobuf::Fingerprint& Transport::_internal_fingerprint() const {
  const ::zorro::protobuf::Fingerprint* p = fingerprint_;
  return p != nullptr ? *p : reinterpret_cast<const ::zorro::protobuf::Fingerprint&>(
      ::zorro::protobuf::_Fingerprint_default_instance_);
}
inline const ::zorro::protobuf::Fingerprint& Transport::fingerprint() const {
  // @@protoc_insertion_point(field_get:zorro.protobuf.Transport.fingerprint)
  return _internal_fingerprint();
}
inline void Transport::unsafe_arena_set_allocated_fingerprint(
    ::zorro::protobuf::Fingerprint* fingerprint) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(fingerprint_);
  }
  fingerprint_ = fingerprint;
  if (fingerprint) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:zorro.protobuf.Transport.fingerprint)
}
inline ::zorro::protobuf::Fingerprint* Transport::release_fingerprint() {
  
  ::zorro::protobuf::Fingerprint* temp = fingerprint_;
  fingerprint_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::zorro::protobuf::Fingerprint* Transport::unsafe_arena_release_fingerprint() {
  // @@protoc_insertion_point(field_release:zorro.protobuf.Transport.fingerprint)
  
  ::zorro::protobuf::Fingerprint* temp = fingerprint_;
  fingerprint_ = nullptr;
  return temp;
}
inline ::zorro::protobuf::Fingerprint* Transport::_internal_mutable_fingerprint() {
  
  if (fingerprint_ == nullptr) {
    auto* p = CreateMaybeMessage<::zorro::protobuf::Fingerprint>(GetArenaForAllocation());
    fingerprint_ = p;
  }
  return fingerprint_;
}
inline ::zorro::protobuf::Fingerprint* Transport::mutable_fingerprint() {
  ::zorro::protobuf::Fingerprint* _msg = _internal_mutable_fingerprint();
  // @@protoc_insertion_point(field_mutable:zorro.protobuf.Transport.fingerprint)
  return _msg;
}
inline void Transport::set_allocated_fingerprint(::zorro::protobuf::Fingerprint* fingerprint) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete fingerprint_;
  }
  if (fingerprint) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::zorro::protobuf::Fingerprint>::GetOwningArena(fingerprint);
    if (message_arena != submessage_arena) {
      fingerprint = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, fingerprint, submessage_arena);
    }
    
  } else {
    
  }
  fingerprint_ = fingerprint;
  // @@protoc_insertion_point(field_set_allocated:zorro.protobuf.Transport.fingerprint)
}

// repeated .zorro.protobuf.Candidate candidates = 5;
inline int Transport::_internal_candidates_size() const {
  return candidates_.size();
}
inline int Transport::candidates_size() const {
  return _internal_candidates_size();
}
inline void Transport::clear_candidates() {
  candidates_.Clear();
}
inline ::zorro::protobuf::Candidate* Transport::mutable_candidates(int index) {
  // @@protoc_insertion_point(field_mutable:zorro.protobuf.Transport.candidates)
  return candidates_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zorro::protobuf::Candidate >*
Transport::mutable_candidates() {
  // @@protoc_insertion_point(field_mutable_list:zorro.protobuf.Transport.candidates)
  return &candidates_;
}
inline const ::zorro::protobuf::Candidate& Transport::_internal_candidates(int index) const {
  return candidates_.Get(index);
}
inline const ::zorro::protobuf::Candidate& Transport::candidates(int index) const {
  // @@protoc_insertion_point(field_get:zorro.protobuf.Transport.candidates)
  return _internal_candidates(index);
}
inline ::zorro::protobuf::Candidate* Transport::_internal_add_candidates() {
  return candidates_.Add();
}
inline ::zorro::protobuf::Candidate* Transport::add_candidates() {
  ::zorro::protobuf::Candidate* _add = _internal_add_candidates();
  // @@protoc_insertion_point(field_add:zorro.protobuf.Transport.candidates)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zorro::protobuf::Candidate >&
Transport::candidates() const {
  // @@protoc_insertion_point(field_list:zorro.protobuf.Transport.candidates)
  return candidates_;
}

// .zorro.protobuf.Crypto crypto = 6;
inline bool Transport::_internal_has_crypto() const {
  return this != internal_default_instance() && crypto_ != nullptr;
}
inline bool Transport::has_crypto() const {
  return _internal_has_crypto();
}
inline void Transport::clear_crypto() {
  if (GetArenaForAllocation() == nullptr && crypto_ != nullptr) {
    delete crypto_;
  }
  crypto_ = nullptr;
}
inline const ::zorro::protobuf::Crypto& Transport::_internal_crypto() const {
  const ::zorro::protobuf::Crypto* p = crypto_;
  return p != nullptr ? *p : reinterpret_cast<const ::zorro::protobuf::Crypto&>(
      ::zorro::protobuf::_Crypto_default_instance_);
}
inline const ::zorro::protobuf::Crypto& Transport::crypto() const {
  // @@protoc_insertion_point(field_get:zorro.protobuf.Transport.crypto)
  return _internal_crypto();
}
inline void Transport::unsafe_arena_set_allocated_crypto(
    ::zorro::protobuf::Crypto* crypto) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(crypto_);
  }
  crypto_ = crypto;
  if (crypto) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:zorro.protobuf.Transport.crypto)
}
inline ::zorro::protobuf::Crypto* Transport::release_crypto() {
  
  ::zorro::protobuf::Crypto* temp = crypto_;
  crypto_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::zorro::protobuf::Crypto* Transport::unsafe_arena_release_crypto() {
  // @@protoc_insertion_point(field_release:zorro.protobuf.Transport.crypto)
  
  ::zorro::protobuf::Crypto* temp = crypto_;
  crypto_ = nullptr;
  return temp;
}
inline ::zorro::protobuf::Crypto* Transport::_internal_mutable_crypto() {
  
  if (crypto_ == nullptr) {
    auto* p = CreateMaybeMessage<::zorro::protobuf::Crypto>(GetArenaForAllocation());
    crypto_ = p;
  }
  return crypto_;
}
inline ::zorro::protobuf::Crypto* Transport::mutable_crypto() {
  ::zorro::protobuf::Crypto* _msg = _internal_mutable_crypto();
  // @@protoc_insertion_point(field_mutable:zorro.protobuf.Transport.crypto)
  return _msg;
}
inline void Transport::set_allocated_crypto(::zorro::protobuf::Crypto* crypto) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete crypto_;
  }
  if (crypto) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::zorro::protobuf::Crypto>::GetOwningArena(crypto);
    if (message_arena != submessage_arena) {
      crypto = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, crypto, submessage_arena);
    }
    
  } else {
    
  }
  crypto_ = crypto;
  // @@protoc_insertion_point(field_set_allocated:zorro.protobuf.Transport.crypto)
}

// -------------------------------------------------------------------

// Content

// string creator = 1;
inline void Content::clear_creator() {
  creator_.ClearToEmpty();
}
inline const std::string& Content::creator() const {
  // @@protoc_insertion_point(field_get:zorro.protobuf.Content.creator)
  return _internal_creator();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Content::set_creator(ArgT0&& arg0, ArgT... args) {
 
 creator_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:zorro.protobuf.Content.creator)
}
inline std::string* Content::mutable_creator() {
  std::string* _s = _internal_mutable_creator();
  // @@protoc_insertion_point(field_mutable:zorro.protobuf.Content.creator)
  return _s;
}
inline const std::string& Content::_internal_creator() const {
  return creator_.Get();
}
inline void Content::_internal_set_creator(const std::string& value) {
  
  creator_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Content::_internal_mutable_creator() {
  
  return creator_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Content::release_creator() {
  // @@protoc_insertion_point(field_release:zorro.protobuf.Content.creator)
  return creator_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Content::set_allocated_creator(std::string* creator) {
  if (creator != nullptr) {
    
  } else {
    
  }
  creator_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), creator,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (creator_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    creator_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:zorro.protobuf.Content.creator)
}

// string name = 2;
inline void Content::clear_name() {
  name_.ClearToEmpty();
}
inline const std::string& Content::name() const {
  // @@protoc_insertion_point(field_get:zorro.protobuf.Content.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Content::set_name(ArgT0&& arg0, ArgT... args) {
 
 name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:zorro.protobuf.Content.name)
}
inline std::string* Content::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:zorro.protobuf.Content.name)
  return _s;
}
inline const std::string& Content::_internal_name() const {
  return name_.Get();
}
inline void Content::_internal_set_name(const std::string& value) {
  
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Content::_internal_mutable_name() {
  
  return name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Content::release_name() {
  // @@protoc_insertion_point(field_release:zorro.protobuf.Content.name)
  return name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Content::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (name_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:zorro.protobuf.Content.name)
}

// string senders = 3;
inline void Content::clear_senders() {
  senders_.ClearToEmpty();
}
inline const std::string& Content::senders() const {
  // @@protoc_insertion_point(field_get:zorro.protobuf.Content.senders)
  return _internal_senders();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Content::set_senders(ArgT0&& arg0, ArgT... args) {
 
 senders_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:zorro.protobuf.Content.senders)
}
inline std::string* Content::mutable_senders() {
  std::string* _s = _internal_mutable_senders();
  // @@protoc_insertion_point(field_mutable:zorro.protobuf.Content.senders)
  return _s;
}
inline const std::string& Content::_internal_senders() const {
  return senders_.Get();
}
inline void Content::_internal_set_senders(const std::string& value) {
  
  senders_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Content::_internal_mutable_senders() {
  
  return senders_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Content::release_senders() {
  // @@protoc_insertion_point(field_release:zorro.protobuf.Content.senders)
  return senders_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Content::set_allocated_senders(std::string* senders) {
  if (senders != nullptr) {
    
  } else {
    
  }
  senders_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), senders,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (senders_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    senders_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:zorro.protobuf.Content.senders)
}

// .zorro.protobuf.Description description = 4;
inline bool Content::_internal_has_description() const {
  return this != internal_default_instance() && description_ != nullptr;
}
inline bool Content::has_description() const {
  return _internal_has_description();
}
inline void Content::clear_description() {
  if (GetArenaForAllocation() == nullptr && description_ != nullptr) {
    delete description_;
  }
  description_ = nullptr;
}
inline const ::zorro::protobuf::Description& Content::_internal_description() const {
  const ::zorro::protobuf::Description* p = description_;
  return p != nullptr ? *p : reinterpret_cast<const ::zorro::protobuf::Description&>(
      ::zorro::protobuf::_Description_default_instance_);
}
inline const ::zorro::protobuf::Description& Content::description() const {
  // @@protoc_insertion_point(field_get:zorro.protobuf.Content.description)
  return _internal_description();
}
inline void Content::unsafe_arena_set_allocated_description(
    ::zorro::protobuf::Description* description) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(description_);
  }
  description_ = description;
  if (description) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:zorro.protobuf.Content.description)
}
inline ::zorro::protobuf::Description* Content::release_description() {
  
  ::zorro::protobuf::Description* temp = description_;
  description_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::zorro::protobuf::Description* Content::unsafe_arena_release_description() {
  // @@protoc_insertion_point(field_release:zorro.protobuf.Content.description)
  
  ::zorro::protobuf::Description* temp = description_;
  description_ = nullptr;
  return temp;
}
inline ::zorro::protobuf::Description* Content::_internal_mutable_description() {
  
  if (description_ == nullptr) {
    auto* p = CreateMaybeMessage<::zorro::protobuf::Description>(GetArenaForAllocation());
    description_ = p;
  }
  return description_;
}
inline ::zorro::protobuf::Description* Content::mutable_description() {
  ::zorro::protobuf::Description* _msg = _internal_mutable_description();
  // @@protoc_insertion_point(field_mutable:zorro.protobuf.Content.description)
  return _msg;
}
inline void Content::set_allocated_description(::zorro::protobuf::Description* description) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete description_;
  }
  if (description) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::zorro::protobuf::Description>::GetOwningArena(description);
    if (message_arena != submessage_arena) {
      description = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, description, submessage_arena);
    }
    
  } else {
    
  }
  description_ = description;
  // @@protoc_insertion_point(field_set_allocated:zorro.protobuf.Content.description)
}

// .zorro.protobuf.Transport transport = 5;
inline bool Content::_internal_has_transport() const {
  return this != internal_default_instance() && transport_ != nullptr;
}
inline bool Content::has_transport() const {
  return _internal_has_transport();
}
inline void Content::clear_transport() {
  if (GetArenaForAllocation() == nullptr && transport_ != nullptr) {
    delete transport_;
  }
  transport_ = nullptr;
}
inline const ::zorro::protobuf::Transport& Content::_internal_transport() const {
  const ::zorro::protobuf::Transport* p = transport_;
  return p != nullptr ? *p : reinterpret_cast<const ::zorro::protobuf::Transport&>(
      ::zorro::protobuf::_Transport_default_instance_);
}
inline const ::zorro::protobuf::Transport& Content::transport() const {
  // @@protoc_insertion_point(field_get:zorro.protobuf.Content.transport)
  return _internal_transport();
}
inline void Content::unsafe_arena_set_allocated_transport(
    ::zorro::protobuf::Transport* transport) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(transport_);
  }
  transport_ = transport;
  if (transport) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:zorro.protobuf.Content.transport)
}
inline ::zorro::protobuf::Transport* Content::release_transport() {
  
  ::zorro::protobuf::Transport* temp = transport_;
  transport_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::zorro::protobuf::Transport* Content::unsafe_arena_release_transport() {
  // @@protoc_insertion_point(field_release:zorro.protobuf.Content.transport)
  
  ::zorro::protobuf::Transport* temp = transport_;
  transport_ = nullptr;
  return temp;
}
inline ::zorro::protobuf::Transport* Content::_internal_mutable_transport() {
  
  if (transport_ == nullptr) {
    auto* p = CreateMaybeMessage<::zorro::protobuf::Transport>(GetArenaForAllocation());
    transport_ = p;
  }
  return transport_;
}
inline ::zorro::protobuf::Transport* Content::mutable_transport() {
  ::zorro::protobuf::Transport* _msg = _internal_mutable_transport();
  // @@protoc_insertion_point(field_mutable:zorro.protobuf.Content.transport)
  return _msg;
}
inline void Content::set_allocated_transport(::zorro::protobuf::Transport* transport) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete transport_;
  }
  if (transport) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::zorro::protobuf::Transport>::GetOwningArena(transport);
    if (message_arena != submessage_arena) {
      transport = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, transport, submessage_arena);
    }
    
  } else {
    
  }
  transport_ = transport;
  // @@protoc_insertion_point(field_set_allocated:zorro.protobuf.Content.transport)
}

// -------------------------------------------------------------------

// SDP

// repeated .zorro.protobuf.Content contents = 1;
inline int SDP::_internal_contents_size() const {
  return contents_.size();
}
inline int SDP::contents_size() const {
  return _internal_contents_size();
}
inline void SDP::clear_contents() {
  contents_.Clear();
}
inline ::zorro::protobuf::Content* SDP::mutable_contents(int index) {
  // @@protoc_insertion_point(field_mutable:zorro.protobuf.SDP.contents)
  return contents_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zorro::protobuf::Content >*
SDP::mutable_contents() {
  // @@protoc_insertion_point(field_mutable_list:zorro.protobuf.SDP.contents)
  return &contents_;
}
inline const ::zorro::protobuf::Content& SDP::_internal_contents(int index) const {
  return contents_.Get(index);
}
inline const ::zorro::protobuf::Content& SDP::contents(int index) const {
  // @@protoc_insertion_point(field_get:zorro.protobuf.SDP.contents)
  return _internal_contents(index);
}
inline ::zorro::protobuf::Content* SDP::_internal_add_contents() {
  return contents_.Add();
}
inline ::zorro::protobuf::Content* SDP::add_contents() {
  ::zorro::protobuf::Content* _add = _internal_add_contents();
  // @@protoc_insertion_point(field_add:zorro.protobuf.SDP.contents)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zorro::protobuf::Content >&
SDP::contents() const {
  // @@protoc_insertion_point(field_list:zorro.protobuf.SDP.contents)
  return contents_;
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// RoomMessage

// string action = 1;
inline void RoomMessage::clear_action() {
  action_.ClearToEmpty();
}
inline const std::string& RoomMessage::action() const {
  // @@protoc_insertion_point(field_get:zorro.protobuf.RoomMessage.action)
  return _internal_action();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RoomMessage::set_action(ArgT0&& arg0, ArgT... args) {
 
 action_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:zorro.protobuf.RoomMessage.action)
}
inline std::string* RoomMessage::mutable_action() {
  std::string* _s = _internal_mutable_action();
  // @@protoc_insertion_point(field_mutable:zorro.protobuf.RoomMessage.action)
  return _s;
}
inline const std::string& RoomMessage::_internal_action() const {
  return action_.Get();
}
inline void RoomMessage::_internal_set_action(const std::string& value) {
  
  action_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* RoomMessage::_internal_mutable_action() {
  
  return action_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* RoomMessage::release_action() {
  // @@protoc_insertion_point(field_release:zorro.protobuf.RoomMessage.action)
  return action_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void RoomMessage::set_allocated_action(std::string* action) {
  if (action != nullptr) {
    
  } else {
    
  }
  action_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), action,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (action_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    action_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:zorro.protobuf.RoomMessage.action)
}

// string userId = 2;
inline void RoomMessage::clear_userid() {
  userid_.ClearToEmpty();
}
inline const std::string& RoomMessage::userid() const {
  // @@protoc_insertion_point(field_get:zorro.protobuf.RoomMessage.userId)
  return _internal_userid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RoomMessage::set_userid(ArgT0&& arg0, ArgT... args) {
 
 userid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:zorro.protobuf.RoomMessage.userId)
}
inline std::string* RoomMessage::mutable_userid() {
  std::string* _s = _internal_mutable_userid();
  // @@protoc_insertion_point(field_mutable:zorro.protobuf.RoomMessage.userId)
  return _s;
}
inline const std::string& RoomMessage::_internal_userid() const {
  return userid_.Get();
}
inline void RoomMessage::_internal_set_userid(const std::string& value) {
  
  userid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* RoomMessage::_internal_mutable_userid() {
  
  return userid_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* RoomMessage::release_userid() {
  // @@protoc_insertion_point(field_release:zorro.protobuf.RoomMessage.userId)
  return userid_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void RoomMessage::set_allocated_userid(std::string* userid) {
  if (userid != nullptr) {
    
  } else {
    
  }
  userid_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), userid,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (userid_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    userid_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:zorro.protobuf.RoomMessage.userId)
}

// string roomId = 3;
inline void RoomMessage::clear_roomid() {
  roomid_.ClearToEmpty();
}
inline const std::string& RoomMessage::roomid() const {
  // @@protoc_insertion_point(field_get:zorro.protobuf.RoomMessage.roomId)
  return _internal_roomid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RoomMessage::set_roomid(ArgT0&& arg0, ArgT... args) {
 
 roomid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:zorro.protobuf.RoomMessage.roomId)
}
inline std::string* RoomMessage::mutable_roomid() {
  std::string* _s = _internal_mutable_roomid();
  // @@protoc_insertion_point(field_mutable:zorro.protobuf.RoomMessage.roomId)
  return _s;
}
inline const std::string& RoomMessage::_internal_roomid() const {
  return roomid_.Get();
}
inline void RoomMessage::_internal_set_roomid(const std::string& value) {
  
  roomid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* RoomMessage::_internal_mutable_roomid() {
  
  return roomid_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* RoomMessage::release_roomid() {
  // @@protoc_insertion_point(field_release:zorro.protobuf.RoomMessage.roomId)
  return roomid_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void RoomMessage::set_allocated_roomid(std::string* roomid) {
  if (roomid != nullptr) {
    
  } else {
    
  }
  roomid_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), roomid,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (roomid_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    roomid_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:zorro.protobuf.RoomMessage.roomId)
}

// string region = 4;
inline void RoomMessage::clear_region() {
  region_.ClearToEmpty();
}
inline const std::string& RoomMessage::region() const {
  // @@protoc_insertion_point(field_get:zorro.protobuf.RoomMessage.region)
  return _internal_region();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RoomMessage::set_region(ArgT0&& arg0, ArgT... args) {
 
 region_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:zorro.protobuf.RoomMessage.region)
}
inline std::string* RoomMessage::mutable_region() {
  std::string* _s = _internal_mutable_region();
  // @@protoc_insertion_point(field_mutable:zorro.protobuf.RoomMessage.region)
  return _s;
}
inline const std::string& RoomMessage::_internal_region() const {
  return region_.Get();
}
inline void RoomMessage::_internal_set_region(const std::string& value) {
  
  region_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* RoomMessage::_internal_mutable_region() {
  
  return region_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* RoomMessage::release_region() {
  // @@protoc_insertion_point(field_release:zorro.protobuf.RoomMessage.region)
  return region_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void RoomMessage::set_allocated_region(std::string* region) {
  if (region != nullptr) {
    
  } else {
    
  }
  region_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), region,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (region_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    region_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:zorro.protobuf.RoomMessage.region)
}

// string serverTopic = 5;
inline void RoomMessage::clear_servertopic() {
  servertopic_.ClearToEmpty();
}
inline const std::string& RoomMessage::servertopic() const {
  // @@protoc_insertion_point(field_get:zorro.protobuf.RoomMessage.serverTopic)
  return _internal_servertopic();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RoomMessage::set_servertopic(ArgT0&& arg0, ArgT... args) {
 
 servertopic_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:zorro.protobuf.RoomMessage.serverTopic)
}
inline std::string* RoomMessage::mutable_servertopic() {
  std::string* _s = _internal_mutable_servertopic();
  // @@protoc_insertion_point(field_mutable:zorro.protobuf.RoomMessage.serverTopic)
  return _s;
}
inline const std::string& RoomMessage::_internal_servertopic() const {
  return servertopic_.Get();
}
inline void RoomMessage::_internal_set_servertopic(const std::string& value) {
  
  servertopic_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* RoomMessage::_internal_mutable_servertopic() {
  
  return servertopic_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* RoomMessage::release_servertopic() {
  // @@protoc_insertion_point(field_release:zorro.protobuf.RoomMessage.serverTopic)
  return servertopic_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void RoomMessage::set_allocated_servertopic(std::string* servertopic) {
  if (servertopic != nullptr) {
    
  } else {
    
  }
  servertopic_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), servertopic,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (servertopic_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    servertopic_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:zorro.protobuf.RoomMessage.serverTopic)
}

// string userTopic = 6;
inline void RoomMessage::clear_usertopic() {
  usertopic_.ClearToEmpty();
}
inline const std::string& RoomMessage::usertopic() const {
  // @@protoc_insertion_point(field_get:zorro.protobuf.RoomMessage.userTopic)
  return _internal_usertopic();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RoomMessage::set_usertopic(ArgT0&& arg0, ArgT... args) {
 
 usertopic_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:zorro.protobuf.RoomMessage.userTopic)
}
inline std::string* RoomMessage::mutable_usertopic() {
  std::string* _s = _internal_mutable_usertopic();
  // @@protoc_insertion_point(field_mutable:zorro.protobuf.RoomMessage.userTopic)
  return _s;
}
inline const std::string& RoomMessage::_internal_usertopic() const {
  return usertopic_.Get();
}
inline void RoomMessage::_internal_set_usertopic(const std::string& value) {
  
  usertopic_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* RoomMessage::_internal_mutable_usertopic() {
  
  return usertopic_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* RoomMessage::release_usertopic() {
  // @@protoc_insertion_point(field_release:zorro.protobuf.RoomMessage.userTopic)
  return usertopic_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void RoomMessage::set_allocated_usertopic(std::string* usertopic) {
  if (usertopic != nullptr) {
    
  } else {
    
  }
  usertopic_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), usertopic,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (usertopic_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    usertopic_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:zorro.protobuf.RoomMessage.userTopic)
}

// map<string, string> parameterMap = 7;
inline int RoomMessage::_internal_parametermap_size() const {
  return parametermap_.size();
}
inline int RoomMessage::parametermap_size() const {
  return _internal_parametermap_size();
}
inline void RoomMessage::clear_parametermap() {
  parametermap_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
RoomMessage::_internal_parametermap() const {
  return parametermap_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
RoomMessage::parametermap() const {
  // @@protoc_insertion_point(field_map:zorro.protobuf.RoomMessage.parameterMap)
  return _internal_parametermap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
RoomMessage::_internal_mutable_parametermap() {
  return parametermap_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
RoomMessage::mutable_parametermap() {
  // @@protoc_insertion_point(field_mutable_map:zorro.protobuf.RoomMessage.parameterMap)
  return _internal_mutable_parametermap();
}

// repeated string parameterList = 8;
inline int RoomMessage::_internal_parameterlist_size() const {
  return parameterlist_.size();
}
inline int RoomMessage::parameterlist_size() const {
  return _internal_parameterlist_size();
}
inline void RoomMessage::clear_parameterlist() {
  parameterlist_.Clear();
}
inline std::string* RoomMessage::add_parameterlist() {
  std::string* _s = _internal_add_parameterlist();
  // @@protoc_insertion_point(field_add_mutable:zorro.protobuf.RoomMessage.parameterList)
  return _s;
}
inline const std::string& RoomMessage::_internal_parameterlist(int index) const {
  return parameterlist_.Get(index);
}
inline const std::string& RoomMessage::parameterlist(int index) const {
  // @@protoc_insertion_point(field_get:zorro.protobuf.RoomMessage.parameterList)
  return _internal_parameterlist(index);
}
inline std::string* RoomMessage::mutable_parameterlist(int index) {
  // @@protoc_insertion_point(field_mutable:zorro.protobuf.RoomMessage.parameterList)
  return parameterlist_.Mutable(index);
}
inline void RoomMessage::set_parameterlist(int index, const std::string& value) {
  parameterlist_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:zorro.protobuf.RoomMessage.parameterList)
}
inline void RoomMessage::set_parameterlist(int index, std::string&& value) {
  parameterlist_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:zorro.protobuf.RoomMessage.parameterList)
}
inline void RoomMessage::set_parameterlist(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  parameterlist_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:zorro.protobuf.RoomMessage.parameterList)
}
inline void RoomMessage::set_parameterlist(int index, const char* value, size_t size) {
  parameterlist_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:zorro.protobuf.RoomMessage.parameterList)
}
inline std::string* RoomMessage::_internal_add_parameterlist() {
  return parameterlist_.Add();
}
inline void RoomMessage::add_parameterlist(const std::string& value) {
  parameterlist_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:zorro.protobuf.RoomMessage.parameterList)
}
inline void RoomMessage::add_parameterlist(std::string&& value) {
  parameterlist_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:zorro.protobuf.RoomMessage.parameterList)
}
inline void RoomMessage::add_parameterlist(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  parameterlist_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:zorro.protobuf.RoomMessage.parameterList)
}
inline void RoomMessage::add_parameterlist(const char* value, size_t size) {
  parameterlist_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:zorro.protobuf.RoomMessage.parameterList)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
RoomMessage::parameterlist() const {
  // @@protoc_insertion_point(field_list:zorro.protobuf.RoomMessage.parameterList)
  return parameterlist_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
RoomMessage::mutable_parameterlist() {
  // @@protoc_insertion_point(field_mutable_list:zorro.protobuf.RoomMessage.parameterList)
  return &parameterlist_;
}

// .zorro.protobuf.SDP sdp = 9;
inline bool RoomMessage::_internal_has_sdp() const {
  return this != internal_default_instance() && sdp_ != nullptr;
}
inline bool RoomMessage::has_sdp() const {
  return _internal_has_sdp();
}
inline void RoomMessage::clear_sdp() {
  if (GetArenaForAllocation() == nullptr && sdp_ != nullptr) {
    delete sdp_;
  }
  sdp_ = nullptr;
}
inline const ::zorro::protobuf::SDP& RoomMessage::_internal_sdp() const {
  const ::zorro::protobuf::SDP* p = sdp_;
  return p != nullptr ? *p : reinterpret_cast<const ::zorro::protobuf::SDP&>(
      ::zorro::protobuf::_SDP_default_instance_);
}
inline const ::zorro::protobuf::SDP& RoomMessage::sdp() const {
  // @@protoc_insertion_point(field_get:zorro.protobuf.RoomMessage.sdp)
  return _internal_sdp();
}
inline void RoomMessage::unsafe_arena_set_allocated_sdp(
    ::zorro::protobuf::SDP* sdp) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(sdp_);
  }
  sdp_ = sdp;
  if (sdp) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:zorro.protobuf.RoomMessage.sdp)
}
inline ::zorro::protobuf::SDP* RoomMessage::release_sdp() {
  
  ::zorro::protobuf::SDP* temp = sdp_;
  sdp_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::zorro::protobuf::SDP* RoomMessage::unsafe_arena_release_sdp() {
  // @@protoc_insertion_point(field_release:zorro.protobuf.RoomMessage.sdp)
  
  ::zorro::protobuf::SDP* temp = sdp_;
  sdp_ = nullptr;
  return temp;
}
inline ::zorro::protobuf::SDP* RoomMessage::_internal_mutable_sdp() {
  
  if (sdp_ == nullptr) {
    auto* p = CreateMaybeMessage<::zorro::protobuf::SDP>(GetArenaForAllocation());
    sdp_ = p;
  }
  return sdp_;
}
inline ::zorro::protobuf::SDP* RoomMessage::mutable_sdp() {
  ::zorro::protobuf::SDP* _msg = _internal_mutable_sdp();
  // @@protoc_insertion_point(field_mutable:zorro.protobuf.RoomMessage.sdp)
  return _msg;
}
inline void RoomMessage::set_allocated_sdp(::zorro::protobuf::SDP* sdp) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete sdp_;
  }
  if (sdp) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::zorro::protobuf::SDP>::GetOwningArena(sdp);
    if (message_arena != submessage_arena) {
      sdp = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, sdp, submessage_arena);
    }
    
  } else {
    
  }
  sdp_ = sdp;
  // @@protoc_insertion_point(field_set_allocated:zorro.protobuf.RoomMessage.sdp)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace protobuf
}  // namespace zorro

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_room_5fmessage_2eproto
